<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>circus.circus API documentation</title>
<meta name="description" content="Gym compatible Analog Circuit Environment" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>circus.circus</code></h1>
</header>
<section id="section-intro">
<p>Gym compatible Analog Circuit Environment</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34; Gym compatible Analog Circuit Environment &#34;&#34;&#34;

import os
from functools import partial
from collections import OrderedDict
from typing import Any, List, Optional, Type, Union, Callable
import gym
from gym.spaces import Dict, Box
from gym import GoalEnv
from stable_baselines3.common.vec_env.base_vec_env import VecEnv, \
                                                          VecEnvIndices, \
                                                          VecEnvStepReturn

import numpy as np
import hace as ac

from .util   import *
from .reward import *
from .ace    import *
from .prim   import *
from .trafo  import *

class CircusGeom(GoalEnv, VecEnv):
    &#34;&#34;&#34; Geometric Sizing Goal Environment &#34;&#34;&#34;
    def __init__( self
                , ace_id: str
                , ace_backend: str
                , num_envs: int                    = 1
                , num_steps: int                   = 50
                , seed: int                        = 666
                , obs_filter: Union[str,List[str]] = &#39;perf&#39;
                , goal_filter: [str]               = None
                , goal_preds: [Callable]           = None
                , reward_fn: Callable              = None
                , scale_observation: bool          = True
                , ):
        &#34;&#34;&#34;
        Construct a Geometric Sizing Goal Environment
        Arguments:
            `ace_id`:            ID of the form &#39;op#&#39;, see ACE Documentation for further
                                 details.
            `ace_backend`:       PDK, available are &#39;xh035&#39; and &#39;xh018&#39;.
            `num_envs`:          Numer of Parallel Environments âˆˆ [ 1 .. `nproc` ]
            `num_steps`:         Number of steps per Episode.
            `seed`:              Random Seed
            `obs_filter`:        Filter Performance dict obtained from ACE.
                                 &#39;perf&#39;: Only performance paramters
                                 &#39;all&#39;: All parameters from ACE
                                 [str]: List of parameters
            `goal_filter`:       List of parameters
            `goal_preds`:        Binary comparison operator
            `reward_fn`:         Optional reward function that takes an observation dict.
            `scale_observation`: Scale the observations and goals as specified in trafo
        &#34;&#34;&#34;

        self.ace_id: str       = ace_id
        self.ace_backend: str  = ace_backend
        self.num_envs: int     = num_envs

        self.num_steps: int    = num_steps
        self.steps: np.array   = np.zeros(num_envs)

        self.ace_envs          = ac.make_same_env_pool( self.num_envs
                                                      , self.ace_id
                                                      , self.ace_backend )

        self.constraints       = ac.parameter_dict(self.ace_envs[0])

        perf_ids               = sorted(ac.performance_identifiers(self.ace_envs[0]))
        self.obs_filter        = ( perf_ids if obs_filter == &#39;all&#39; else
                                   [p for p in perf_ids if (p.islower() or (p == &#39;A&#39;))]
                                   if obs_filter == &#39;perf&#39; else
                                   obs_filter if isinstance(obs_filter, list)
                                   else ValueError(&#39;Wrong Argument type passed to obs_filter.&#39;) )

        self.obs_idx           = np.array([ i for i,p in enumerate(self.obs_filter)
                                            if p in self.obs_filter ])

        self.obs_scaler,_      = performance_scaler( self.ace_id
                                                   , self.ace_backend
                                                   , self.constraints
                                                   , self.obs_filter
                                                   , )

        self.input_parameters  = ac.sizing_identifiers(self.ace_envs[0])

        self.goal_filter       = goal_filter or [ ident for ident in self.obs_filter
                                                  if ident.islower() or (ident == &#39;A&#39;) ]

        self.goal_idx          = np.array([i for i,p in enumerate(self.obs_filter)
                                             if p in self.goal_filter])

        self.goal_preds        = goal_preds or goal_predicate(self.goal_filter)

        self.goal_scaler,_     = performance_scaler( self.ace_id
                                                   , self.ace_backend
                                                   , self.constraints
                                                   , self.goal_filter
                                                   , )

        self.calculate_reward  = reward_fn or partial(binary_reward, self.goal_preds)

        self.action_space      = Box( low   = -1.0
                                    , high  = 1.0
                                    , shape = (len(self.input_parameters),)
                                    , dtype = np.float32 )

        self.observation_space = Dict({ &#39;observation&#39;:   Box( -np.Inf, np.Inf
                                                            , (len(self.obs_filter),))
                                      , &#39;achieved_goal&#39;: Box( -np.Inf, np.Inf
                                                            , (len(self.goal_filter),))
                                      , &#39;desired_goal&#39;:  Box( -np.Inf, np.Inf
                                                            , (len(self.goal_filter),))
                                      , })

        self.scale_observation = scale_observation

        self.rng_seed          = seed

        pool                   = { i: self.ace_envs[i]
                                   for i in range(self.num_envs) }
        initial_sizing         = ac.initial_sizing_pool(pool)
        results                = ac.evaluate_circuit_pool(pool, pool_params = initial_sizing)
        self.reference_goal    = filter_results(self.goal_filter, results)
        self.goal              = add_noise(self.reference_goal)

        self.unscale_action    = geometric_unscaler(self.constraints)

        self.sizing            = {}

        VecEnv.__init__( self, self.num_envs
                       , self.observation_space
                       , self.action_space )

    def close(self, env_ids: list[int] = None) -&gt; None:
        &#34;&#34;&#34;
        Close all (parallel) ACE environment(s).
        Arguments:
            `env_ids`: List of environemt IDs that will be closed.
                       Default = None closes all.
        &#34;&#34;&#34;
        for env_id in (env_ids or self.ace_envs.keys()):
            self.ace_envs[env_id].clear()

    def reset(self, env_mask: [bool] = [], env_ids: [int] = []):
        &#34;&#34;&#34;
        Reset all (parallel) environemt(s).
        Arguments:
            `env_mask`: Boolean mask of environemts that will be reset. Passing
                        the `done` vector works. (Presendece)
            `env_ids`: List of integer IDs of environemts that will be reset.
        &#34;&#34;&#34;
        reset_ids     = [ i for i,m in enumerate(env_mask) if m
                        ] or env_ids or range(self.num_envs)
        pool          = { i: self.ace_envs[i] for i in reset_ids }
        random_sizing = ac.random_sizing_pool(pool)
        results       = ac.evaluate_circuit_pool(pool, pool_params = random_sizing)
        self.goal     = add_noise(self.reference_goal)
        state         = filter_results(self.obs_filter, results)
        achieved      = filter_results(self.goal_filter, results)
        observation   = OrderedDict({ &#39;observation&#39;:   ( self.obs_scaler(state)
                                                         if self.scale_observation
                                                         else state )
                                    , &#39;achieved_goal&#39;: ( self.goal_scaler(achieved)
                                                         if self.scale_observation
                                                         else achieved )
                                    , &#39;desired_goal&#39;:  ( self.goal_scaler(self.goal)
                                                         if self.scale_observation
                                                         else self.goal ) })

        self.steps[reset_ids] = 0

        return observation

    def step(self, actions: np.ndarray) -&gt; VecEnvStepReturn:
        &#34;&#34;&#34;
        Take a step in the Environment. Calls `step_async` and `step_wait`
        under the hood.
        Arguments:
            `actions`: Take Action with shape [num_envs, action_space].
        &#34;&#34;&#34;
        self.step_async(actions)
        return self.step_wait()

    def step_async(self, actions: np.ndarray) -&gt; None:
        &#34;&#34;&#34;
        Initiate a step in the Environment. 
        Arguments:
            `actions`: Take Action with shape [num_envs, action_space].
        &#34;&#34;&#34;
        unscaled    = list(self.unscale_action(actions))
        params      = sorted(ac.sizing_identifiers(self.ace_envs[0]))
        self.sizing = { env_id: dict(zip(params, action.tolist()))
                        for env_id,action in enumerate(unscaled)}

    def step_wait(self) -&gt; VecEnvStepReturn:
        &#34;&#34;&#34;
        Complete a step in the Environment.
        &#34;&#34;&#34;
        pool        = { i: self.ace_envs[i] for i in range(self.num_envs) }
        results     = ac.evaluate_circuit_pool(pool, pool_params = self.sizing)

        state       = filter_results(self.obs_filter, results)
        achieved    = filter_results(self.goal_filter, results)

        observation = OrderedDict({ &#39;observation&#39;:   ( self.obs_scaler(state)
                                                       if self.scale_observation
                                                       else state )
                                  , &#39;achieved_goal&#39;: ( self.goal_scaler(achieved)
                                                       if self.scale_observation
                                                       else achieved )
                                  , &#39;desired_goal&#39;:  ( self.goal_scaler(self.goal)
                                                       if self.scale_observation
                                                       else self.goal ) })

        reward      = self.calculate_reward(observation)

        self.steps  = self.steps + 1

        done        = (reward == 0) | (self.steps &gt;= self.num_steps)

        info        = [{ &#39;outputs&#39;: self.obs_filter
                       , &#39;goal&#39;:    self.goal_filter
                       , &#39;inputs&#39;:  self.input_parameters
                       , }] * self.num_envs

        return (observation, reward, done, info)

    def get_attr( self, attr_name: str, indices: VecEnvIndices = None
                ) -&gt; List[Any]:
        target_envs = self._get_target_envs(indices)
        return [getattr(env_i, attr_name) for env_i in target_envs]

    def set_attr( self, attr_name: str, value: Any
                , indices: VecEnvIndices = None) -&gt; None:
        target_envs = self._get_target_envs(indices)
        for env_i in target_envs:
            setattr(env_i, attr_name, value)

    def env_method( self, method_name: str, *method_args
                  , indices: VecEnvIndices = None, **method_kwargs
                  ) -&gt; List[Any]:
        target_envs = self._get_target_envs(indices)
        return [ getattr(env_i, method_name)(*method_args, **method_kwargs)
                 for env_i in target_envs ]

    def env_is_wrapped( self, wrapper_class: Type[gym.Wrapper]
                      , indices: VecEnvIndices = None) -&gt; List[bool]:
        return [False for _ in range(self.num_envs)]

    def _get_target_envs(self, indices: VecEnvIndices) -&gt; List[gym.Env]:
        return [self]

    def seed(self, seed: Optional[int] = None) -&gt; List[Union[None, int]]:
        self.rng_seed = seed
        return [self.rng_seed] * self.num_envs

    def render(self, mode: str = &#39;human&#39;) -&gt; Optional[np.ndarray]:
        pass

class CircusElec(CircusGeom):
    def __init__(self, **kwargs):
        &#34;&#34;&#34;
        Construct Electric Sizing Goal Environment. Same Arguments as
        `CircusGeom`.
        &#34;&#34;&#34;
        super().__init__(**kwargs)

        nmos_path = os.path.expanduser(f&#39;~/.ace/{self.ace_backend}/nmos&#39;)
        pmos_path = os.path.expanduser(f&#39;~/.ace/{self.ace_backend}/pmos&#39;)
        params_x  = [&#39;gmoverid&#39;, &#39;fug&#39;, &#39;Vds&#39;, &#39;Vbs&#39;]
        params_y  = [&#39;idoverw&#39;, &#39;L&#39;, &#39;gdsoverw&#39;, &#39;Vgs&#39;]
        trafo_x   = [&#39;fug&#39;]
        trafo_y   = [&#39;idoverw&#39;, &#39;gdsoverw&#39;]
        self.nmos = PrimitiveDevice(nmos_path, params_x, params_y, trafo_x, trafo_y)
        self.pmos = PrimitiveDevice(pmos_path, params_x, params_y, trafo_x, trafo_y)

        self.transformation = partial( transformation(self.ace_id)
                                     , self.constraints
                                     , self.nmos
                                     , self.pmos
                                     , )

        self.input_parameters  = electric_identifiers(self.ace_id)

        self.action_space = Box( low   = -1.0
                               , high  = 1.0
                               , shape = (len(self.input_parameters),)
                               , dtype = np.float32 )

        self.unscale_action = electric_unscaler(self.ace_id, self.ace_backend)

    def step_async(self, actions: np.ndarray) -&gt; None:
        unscaled    = list(self.unscale_action(actions))
        self.sizing = { env_id: self.transformation(* action.flatten().tolist())
                        for env_id,action in enumerate(unscaled) }

class CircusGeomVec(CircusGeom):
    &#34;&#34;&#34; Geometric Sizing Non-Goal Environment &#34;&#34;&#34;
    def __init__(self, reward_fn: Callable = dummy_reward, **kwargs):
        &#34;&#34;&#34;
        Construct Geometric Sizing Non-Goal Environment. Same Arguments as
        `CircusGeom` but different default `reward_fn`.
        &#34;&#34;&#34;
        super().__init__(**(kwargs | {&#39;reward_fn&#39;: reward_fn}))
        self.observation_space = self.observation_space[&#39;observation&#39;]

    def reset(self, **kwargs) -&gt; np.array:
        obs = super().reset(**kwargs)
        return obs[&#39;observation&#39;]

    def step_wait(self) -&gt; VecEnvStepReturn:
        obs, _, done, info = super().step_wait()
        observation        = obs[&#39;observation&#39;]
        reward             = self.calculate_reward(observation)
        return (observation, reward, done, info)

class CircusElecVec(CircusElec):
    &#34;&#34;&#34; Geometric Sizing Non-Goal Environment &#34;&#34;&#34;
    def __init__(self, reward_fn: Callable = dummy_reward, **kwargs):
        &#34;&#34;&#34;
        Construct Geometric Sizing Non-Goal Environment. Same Arguments as
        `CircusElec`.
        &#34;&#34;&#34;
        super().__init__(**(kwargs | {&#39;reward_fn&#39;: reward_fn}))
        self.observation_space = self.observation_space[&#39;observation&#39;]

    def reset(self, **kwargs) -&gt; np.array:
        obs = super().reset(**kwargs)
        return obs[&#39;observation&#39;]

    def step_wait(self) -&gt; VecEnvStepReturn:
        obs, _, done, info = super().step_wait()
        observation        = obs[&#39;observation&#39;]
        reward             = self.calculate_reward(observation)
        return (observation, reward, done, info)

def make( env_id: str, n_envs: int = 1, **kwargs
        ) -&gt; Union[CircusGeom, CircusGeomVec]:
    &#34;&#34;&#34;
    Gym Style Environment Constructor, see `gym.make`.
    Arguments:
        `env_id`: Environment ID of the form &#39;&lt;ace id&gt;-&lt;pdk&gt;-&lt;space&gt;-v&lt;var&gt;
        `n_envs`: Number of Environment
        `kwargs`: Will be passed to Circus constructor.
    &#34;&#34;&#34;
    eid,pdk,spc,var = env_id.split(&#39;:&#39;)[1].split(&#39;-&#39;)
    backend = backend_id(pdk)

    env     = ( CircusGeom( ace_id      = eid
                          , ace_backend = backend
                          , num_envs    = n_envs
                          , **kwargs
                          )    if (var == &#39;v0&#39; and spc == &#39;geom&#39;) else
                CircusGeomVec( ace_id      = eid
                             , ace_backend = backend
                             , num_envs    = n_envs
                             , **kwargs
                             ) if (var == &#39;v1&#39; and spc == &#39;geom&#39;) else
                CircusElec( ace_id      = eid
                          , ace_backend = backend
                          , num_envs    = n_envs
                          , **kwargs
                          )    if (var == &#39;v0&#39; and spc == &#39;elec&#39;) else
                CircusElecVec( ace_id      = eid
                             , ace_backend = backend
                             , num_envs    = n_envs
                             , **kwargs
                             ) if (var == &#39;v1&#39; and spc == &#39;elec&#39;) else
                NotImplementedError(f&#39;Variant {var} not available&#39;) )
    return env</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="circus.circus.make"><code class="name flex">
<span>def <span class="ident">make</span></span>(<span>env_id:Â str, n_envs:Â intÂ =Â 1, **kwargs) â€‘>Â Union[<a title="circus.circus.CircusGeom" href="#circus.circus.CircusGeom">CircusGeom</a>,Â <a title="circus.circus.CircusGeomVec" href="#circus.circus.CircusGeomVec">CircusGeomVec</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Gym Style Environment Constructor, see <code>gym.make</code>.</p>
<h2 id="arguments">Arguments</h2>
<p><code>env_id</code>: Environment ID of the form '<ace id>-<pdk>-<space>-v<var>
<code>n_envs</code>: Number of Environment
<code>kwargs</code>: Will be passed to Circus constructor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make( env_id: str, n_envs: int = 1, **kwargs
        ) -&gt; Union[CircusGeom, CircusGeomVec]:
    &#34;&#34;&#34;
    Gym Style Environment Constructor, see `gym.make`.
    Arguments:
        `env_id`: Environment ID of the form &#39;&lt;ace id&gt;-&lt;pdk&gt;-&lt;space&gt;-v&lt;var&gt;
        `n_envs`: Number of Environment
        `kwargs`: Will be passed to Circus constructor.
    &#34;&#34;&#34;
    eid,pdk,spc,var = env_id.split(&#39;:&#39;)[1].split(&#39;-&#39;)
    backend = backend_id(pdk)

    env     = ( CircusGeom( ace_id      = eid
                          , ace_backend = backend
                          , num_envs    = n_envs
                          , **kwargs
                          )    if (var == &#39;v0&#39; and spc == &#39;geom&#39;) else
                CircusGeomVec( ace_id      = eid
                             , ace_backend = backend
                             , num_envs    = n_envs
                             , **kwargs
                             ) if (var == &#39;v1&#39; and spc == &#39;geom&#39;) else
                CircusElec( ace_id      = eid
                          , ace_backend = backend
                          , num_envs    = n_envs
                          , **kwargs
                          )    if (var == &#39;v0&#39; and spc == &#39;elec&#39;) else
                CircusElecVec( ace_id      = eid
                             , ace_backend = backend
                             , num_envs    = n_envs
                             , **kwargs
                             ) if (var == &#39;v1&#39; and spc == &#39;elec&#39;) else
                NotImplementedError(f&#39;Variant {var} not available&#39;) )
    return env</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="circus.circus.CircusElec"><code class="flex name class">
<span>class <span class="ident">CircusElec</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Geometric Sizing Goal Environment </p>
<p>Construct Electric Sizing Goal Environment. Same Arguments as
<code><a title="circus.circus.CircusGeom" href="#circus.circus.CircusGeom">CircusGeom</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CircusElec(CircusGeom):
    def __init__(self, **kwargs):
        &#34;&#34;&#34;
        Construct Electric Sizing Goal Environment. Same Arguments as
        `CircusGeom`.
        &#34;&#34;&#34;
        super().__init__(**kwargs)

        nmos_path = os.path.expanduser(f&#39;~/.ace/{self.ace_backend}/nmos&#39;)
        pmos_path = os.path.expanduser(f&#39;~/.ace/{self.ace_backend}/pmos&#39;)
        params_x  = [&#39;gmoverid&#39;, &#39;fug&#39;, &#39;Vds&#39;, &#39;Vbs&#39;]
        params_y  = [&#39;idoverw&#39;, &#39;L&#39;, &#39;gdsoverw&#39;, &#39;Vgs&#39;]
        trafo_x   = [&#39;fug&#39;]
        trafo_y   = [&#39;idoverw&#39;, &#39;gdsoverw&#39;]
        self.nmos = PrimitiveDevice(nmos_path, params_x, params_y, trafo_x, trafo_y)
        self.pmos = PrimitiveDevice(pmos_path, params_x, params_y, trafo_x, trafo_y)

        self.transformation = partial( transformation(self.ace_id)
                                     , self.constraints
                                     , self.nmos
                                     , self.pmos
                                     , )

        self.input_parameters  = electric_identifiers(self.ace_id)

        self.action_space = Box( low   = -1.0
                               , high  = 1.0
                               , shape = (len(self.input_parameters),)
                               , dtype = np.float32 )

        self.unscale_action = electric_unscaler(self.ace_id, self.ace_backend)

    def step_async(self, actions: np.ndarray) -&gt; None:
        unscaled    = list(self.unscale_action(actions))
        self.sizing = { env_id: self.transformation(* action.flatten().tolist())
                        for env_id,action in enumerate(unscaled) }</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="circus.circus.CircusGeom" href="#circus.circus.CircusGeom">CircusGeom</a></li>
<li>gym.core.GoalEnv</li>
<li>gym.core.Env</li>
<li>stable_baselines3.common.vec_env.base_vec_env.VecEnv</li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="circus.circus.CircusElecVec" href="#circus.circus.CircusElecVec">CircusElecVec</a></li>
<li><a title="circus.gym.op.OPElecV0" href="gym/op.html#circus.gym.op.OPElecV0">OPElecV0</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="circus.circus.CircusGeom" href="#circus.circus.CircusGeom">CircusGeom</a></b></code>:
<ul class="hlist">
<li><code><a title="circus.circus.CircusGeom.close" href="#circus.circus.CircusGeom.close">close</a></code></li>
<li><code><a title="circus.circus.CircusGeom.env_is_wrapped" href="#circus.circus.CircusGeom.env_is_wrapped">env_is_wrapped</a></code></li>
<li><code><a title="circus.circus.CircusGeom.env_method" href="#circus.circus.CircusGeom.env_method">env_method</a></code></li>
<li><code><a title="circus.circus.CircusGeom.get_attr" href="#circus.circus.CircusGeom.get_attr">get_attr</a></code></li>
<li><code><a title="circus.circus.CircusGeom.render" href="#circus.circus.CircusGeom.render">render</a></code></li>
<li><code><a title="circus.circus.CircusGeom.reset" href="#circus.circus.CircusGeom.reset">reset</a></code></li>
<li><code><a title="circus.circus.CircusGeom.seed" href="#circus.circus.CircusGeom.seed">seed</a></code></li>
<li><code><a title="circus.circus.CircusGeom.set_attr" href="#circus.circus.CircusGeom.set_attr">set_attr</a></code></li>
<li><code><a title="circus.circus.CircusGeom.step" href="#circus.circus.CircusGeom.step">step</a></code></li>
<li><code><a title="circus.circus.CircusGeom.step_async" href="#circus.circus.CircusGeom.step_async">step_async</a></code></li>
<li><code><a title="circus.circus.CircusGeom.step_wait" href="#circus.circus.CircusGeom.step_wait">step_wait</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="circus.circus.CircusElecVec"><code class="flex name class">
<span>class <span class="ident">CircusElecVec</span></span>
<span>(</span><span>reward_fn:Â CallableÂ =Â &lt;function dummy_reward&gt;, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Geometric Sizing Non-Goal Environment </p>
<p>Construct Geometric Sizing Non-Goal Environment. Same Arguments as
<code><a title="circus.circus.CircusElec" href="#circus.circus.CircusElec">CircusElec</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CircusElecVec(CircusElec):
    &#34;&#34;&#34; Geometric Sizing Non-Goal Environment &#34;&#34;&#34;
    def __init__(self, reward_fn: Callable = dummy_reward, **kwargs):
        &#34;&#34;&#34;
        Construct Geometric Sizing Non-Goal Environment. Same Arguments as
        `CircusElec`.
        &#34;&#34;&#34;
        super().__init__(**(kwargs | {&#39;reward_fn&#39;: reward_fn}))
        self.observation_space = self.observation_space[&#39;observation&#39;]

    def reset(self, **kwargs) -&gt; np.array:
        obs = super().reset(**kwargs)
        return obs[&#39;observation&#39;]

    def step_wait(self) -&gt; VecEnvStepReturn:
        obs, _, done, info = super().step_wait()
        observation        = obs[&#39;observation&#39;]
        reward             = self.calculate_reward(observation)
        return (observation, reward, done, info)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="circus.circus.CircusElec" href="#circus.circus.CircusElec">CircusElec</a></li>
<li><a title="circus.circus.CircusGeom" href="#circus.circus.CircusGeom">CircusGeom</a></li>
<li>gym.core.GoalEnv</li>
<li>gym.core.Env</li>
<li>stable_baselines3.common.vec_env.base_vec_env.VecEnv</li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="circus.gym.op.OPElecV1" href="gym/op.html#circus.gym.op.OPElecV1">OPElecV1</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="circus.circus.CircusElec" href="#circus.circus.CircusElec">CircusElec</a></b></code>:
<ul class="hlist">
<li><code><a title="circus.circus.CircusElec.close" href="#circus.circus.CircusGeom.close">close</a></code></li>
<li><code><a title="circus.circus.CircusElec.env_is_wrapped" href="#circus.circus.CircusGeom.env_is_wrapped">env_is_wrapped</a></code></li>
<li><code><a title="circus.circus.CircusElec.env_method" href="#circus.circus.CircusGeom.env_method">env_method</a></code></li>
<li><code><a title="circus.circus.CircusElec.get_attr" href="#circus.circus.CircusGeom.get_attr">get_attr</a></code></li>
<li><code><a title="circus.circus.CircusElec.render" href="#circus.circus.CircusGeom.render">render</a></code></li>
<li><code><a title="circus.circus.CircusElec.reset" href="#circus.circus.CircusGeom.reset">reset</a></code></li>
<li><code><a title="circus.circus.CircusElec.seed" href="#circus.circus.CircusGeom.seed">seed</a></code></li>
<li><code><a title="circus.circus.CircusElec.set_attr" href="#circus.circus.CircusGeom.set_attr">set_attr</a></code></li>
<li><code><a title="circus.circus.CircusElec.step" href="#circus.circus.CircusGeom.step">step</a></code></li>
<li><code><a title="circus.circus.CircusElec.step_async" href="#circus.circus.CircusGeom.step_async">step_async</a></code></li>
<li><code><a title="circus.circus.CircusElec.step_wait" href="#circus.circus.CircusGeom.step_wait">step_wait</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="circus.circus.CircusGeom"><code class="flex name class">
<span>class <span class="ident">CircusGeom</span></span>
<span>(</span><span>ace_id:Â str, ace_backend:Â str, num_envs:Â intÂ =Â 1, num_steps:Â intÂ =Â 50, seed:Â intÂ =Â 666, obs_filter:Â Union[str,Â List[str]]Â =Â 'perf', goal_filter:Â [<classÂ 'str'>]Â =Â None, goal_preds:Â [typing.Callable]Â =Â None, reward_fn:Â CallableÂ =Â None, scale_observation:Â boolÂ =Â True)</span>
</code></dt>
<dd>
<div class="desc"><p>Geometric Sizing Goal Environment </p>
<p>Construct a Geometric Sizing Goal Environment</p>
<h2 id="arguments">Arguments</h2>
<p><code>ace_id</code>:
ID of the form 'op#', see ACE Documentation for further
details.
<code>ace_backend</code>:
PDK, available are 'xh035' and 'xh018'.
<code>num_envs</code>:
Numer of Parallel Environments âˆˆ [ 1 .. <code>nproc</code> ]
<code>num_steps</code>:
Number of steps per Episode.
<code>seed</code>:
Random Seed
<code>obs_filter</code>:
Filter Performance dict obtained from ACE.
'perf': Only performance paramters
'all': All parameters from ACE
[str]: List of parameters
<code>goal_filter</code>:
List of parameters
<code>goal_preds</code>:
Binary comparison operator
<code>reward_fn</code>:
Optional reward function that takes an observation dict.
<code>scale_observation</code>: Scale the observations and goals as specified in trafo</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CircusGeom(GoalEnv, VecEnv):
    &#34;&#34;&#34; Geometric Sizing Goal Environment &#34;&#34;&#34;
    def __init__( self
                , ace_id: str
                , ace_backend: str
                , num_envs: int                    = 1
                , num_steps: int                   = 50
                , seed: int                        = 666
                , obs_filter: Union[str,List[str]] = &#39;perf&#39;
                , goal_filter: [str]               = None
                , goal_preds: [Callable]           = None
                , reward_fn: Callable              = None
                , scale_observation: bool          = True
                , ):
        &#34;&#34;&#34;
        Construct a Geometric Sizing Goal Environment
        Arguments:
            `ace_id`:            ID of the form &#39;op#&#39;, see ACE Documentation for further
                                 details.
            `ace_backend`:       PDK, available are &#39;xh035&#39; and &#39;xh018&#39;.
            `num_envs`:          Numer of Parallel Environments âˆˆ [ 1 .. `nproc` ]
            `num_steps`:         Number of steps per Episode.
            `seed`:              Random Seed
            `obs_filter`:        Filter Performance dict obtained from ACE.
                                 &#39;perf&#39;: Only performance paramters
                                 &#39;all&#39;: All parameters from ACE
                                 [str]: List of parameters
            `goal_filter`:       List of parameters
            `goal_preds`:        Binary comparison operator
            `reward_fn`:         Optional reward function that takes an observation dict.
            `scale_observation`: Scale the observations and goals as specified in trafo
        &#34;&#34;&#34;

        self.ace_id: str       = ace_id
        self.ace_backend: str  = ace_backend
        self.num_envs: int     = num_envs

        self.num_steps: int    = num_steps
        self.steps: np.array   = np.zeros(num_envs)

        self.ace_envs          = ac.make_same_env_pool( self.num_envs
                                                      , self.ace_id
                                                      , self.ace_backend )

        self.constraints       = ac.parameter_dict(self.ace_envs[0])

        perf_ids               = sorted(ac.performance_identifiers(self.ace_envs[0]))
        self.obs_filter        = ( perf_ids if obs_filter == &#39;all&#39; else
                                   [p for p in perf_ids if (p.islower() or (p == &#39;A&#39;))]
                                   if obs_filter == &#39;perf&#39; else
                                   obs_filter if isinstance(obs_filter, list)
                                   else ValueError(&#39;Wrong Argument type passed to obs_filter.&#39;) )

        self.obs_idx           = np.array([ i for i,p in enumerate(self.obs_filter)
                                            if p in self.obs_filter ])

        self.obs_scaler,_      = performance_scaler( self.ace_id
                                                   , self.ace_backend
                                                   , self.constraints
                                                   , self.obs_filter
                                                   , )

        self.input_parameters  = ac.sizing_identifiers(self.ace_envs[0])

        self.goal_filter       = goal_filter or [ ident for ident in self.obs_filter
                                                  if ident.islower() or (ident == &#39;A&#39;) ]

        self.goal_idx          = np.array([i for i,p in enumerate(self.obs_filter)
                                             if p in self.goal_filter])

        self.goal_preds        = goal_preds or goal_predicate(self.goal_filter)

        self.goal_scaler,_     = performance_scaler( self.ace_id
                                                   , self.ace_backend
                                                   , self.constraints
                                                   , self.goal_filter
                                                   , )

        self.calculate_reward  = reward_fn or partial(binary_reward, self.goal_preds)

        self.action_space      = Box( low   = -1.0
                                    , high  = 1.0
                                    , shape = (len(self.input_parameters),)
                                    , dtype = np.float32 )

        self.observation_space = Dict({ &#39;observation&#39;:   Box( -np.Inf, np.Inf
                                                            , (len(self.obs_filter),))
                                      , &#39;achieved_goal&#39;: Box( -np.Inf, np.Inf
                                                            , (len(self.goal_filter),))
                                      , &#39;desired_goal&#39;:  Box( -np.Inf, np.Inf
                                                            , (len(self.goal_filter),))
                                      , })

        self.scale_observation = scale_observation

        self.rng_seed          = seed

        pool                   = { i: self.ace_envs[i]
                                   for i in range(self.num_envs) }
        initial_sizing         = ac.initial_sizing_pool(pool)
        results                = ac.evaluate_circuit_pool(pool, pool_params = initial_sizing)
        self.reference_goal    = filter_results(self.goal_filter, results)
        self.goal              = add_noise(self.reference_goal)

        self.unscale_action    = geometric_unscaler(self.constraints)

        self.sizing            = {}

        VecEnv.__init__( self, self.num_envs
                       , self.observation_space
                       , self.action_space )

    def close(self, env_ids: list[int] = None) -&gt; None:
        &#34;&#34;&#34;
        Close all (parallel) ACE environment(s).
        Arguments:
            `env_ids`: List of environemt IDs that will be closed.
                       Default = None closes all.
        &#34;&#34;&#34;
        for env_id in (env_ids or self.ace_envs.keys()):
            self.ace_envs[env_id].clear()

    def reset(self, env_mask: [bool] = [], env_ids: [int] = []):
        &#34;&#34;&#34;
        Reset all (parallel) environemt(s).
        Arguments:
            `env_mask`: Boolean mask of environemts that will be reset. Passing
                        the `done` vector works. (Presendece)
            `env_ids`: List of integer IDs of environemts that will be reset.
        &#34;&#34;&#34;
        reset_ids     = [ i for i,m in enumerate(env_mask) if m
                        ] or env_ids or range(self.num_envs)
        pool          = { i: self.ace_envs[i] for i in reset_ids }
        random_sizing = ac.random_sizing_pool(pool)
        results       = ac.evaluate_circuit_pool(pool, pool_params = random_sizing)
        self.goal     = add_noise(self.reference_goal)
        state         = filter_results(self.obs_filter, results)
        achieved      = filter_results(self.goal_filter, results)
        observation   = OrderedDict({ &#39;observation&#39;:   ( self.obs_scaler(state)
                                                         if self.scale_observation
                                                         else state )
                                    , &#39;achieved_goal&#39;: ( self.goal_scaler(achieved)
                                                         if self.scale_observation
                                                         else achieved )
                                    , &#39;desired_goal&#39;:  ( self.goal_scaler(self.goal)
                                                         if self.scale_observation
                                                         else self.goal ) })

        self.steps[reset_ids] = 0

        return observation

    def step(self, actions: np.ndarray) -&gt; VecEnvStepReturn:
        &#34;&#34;&#34;
        Take a step in the Environment. Calls `step_async` and `step_wait`
        under the hood.
        Arguments:
            `actions`: Take Action with shape [num_envs, action_space].
        &#34;&#34;&#34;
        self.step_async(actions)
        return self.step_wait()

    def step_async(self, actions: np.ndarray) -&gt; None:
        &#34;&#34;&#34;
        Initiate a step in the Environment. 
        Arguments:
            `actions`: Take Action with shape [num_envs, action_space].
        &#34;&#34;&#34;
        unscaled    = list(self.unscale_action(actions))
        params      = sorted(ac.sizing_identifiers(self.ace_envs[0]))
        self.sizing = { env_id: dict(zip(params, action.tolist()))
                        for env_id,action in enumerate(unscaled)}

    def step_wait(self) -&gt; VecEnvStepReturn:
        &#34;&#34;&#34;
        Complete a step in the Environment.
        &#34;&#34;&#34;
        pool        = { i: self.ace_envs[i] for i in range(self.num_envs) }
        results     = ac.evaluate_circuit_pool(pool, pool_params = self.sizing)

        state       = filter_results(self.obs_filter, results)
        achieved    = filter_results(self.goal_filter, results)

        observation = OrderedDict({ &#39;observation&#39;:   ( self.obs_scaler(state)
                                                       if self.scale_observation
                                                       else state )
                                  , &#39;achieved_goal&#39;: ( self.goal_scaler(achieved)
                                                       if self.scale_observation
                                                       else achieved )
                                  , &#39;desired_goal&#39;:  ( self.goal_scaler(self.goal)
                                                       if self.scale_observation
                                                       else self.goal ) })

        reward      = self.calculate_reward(observation)

        self.steps  = self.steps + 1

        done        = (reward == 0) | (self.steps &gt;= self.num_steps)

        info        = [{ &#39;outputs&#39;: self.obs_filter
                       , &#39;goal&#39;:    self.goal_filter
                       , &#39;inputs&#39;:  self.input_parameters
                       , }] * self.num_envs

        return (observation, reward, done, info)

    def get_attr( self, attr_name: str, indices: VecEnvIndices = None
                ) -&gt; List[Any]:
        target_envs = self._get_target_envs(indices)
        return [getattr(env_i, attr_name) for env_i in target_envs]

    def set_attr( self, attr_name: str, value: Any
                , indices: VecEnvIndices = None) -&gt; None:
        target_envs = self._get_target_envs(indices)
        for env_i in target_envs:
            setattr(env_i, attr_name, value)

    def env_method( self, method_name: str, *method_args
                  , indices: VecEnvIndices = None, **method_kwargs
                  ) -&gt; List[Any]:
        target_envs = self._get_target_envs(indices)
        return [ getattr(env_i, method_name)(*method_args, **method_kwargs)
                 for env_i in target_envs ]

    def env_is_wrapped( self, wrapper_class: Type[gym.Wrapper]
                      , indices: VecEnvIndices = None) -&gt; List[bool]:
        return [False for _ in range(self.num_envs)]

    def _get_target_envs(self, indices: VecEnvIndices) -&gt; List[gym.Env]:
        return [self]

    def seed(self, seed: Optional[int] = None) -&gt; List[Union[None, int]]:
        self.rng_seed = seed
        return [self.rng_seed] * self.num_envs

    def render(self, mode: str = &#39;human&#39;) -&gt; Optional[np.ndarray]:
        pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>gym.core.GoalEnv</li>
<li>gym.core.Env</li>
<li>stable_baselines3.common.vec_env.base_vec_env.VecEnv</li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="circus.circus.CircusElec" href="#circus.circus.CircusElec">CircusElec</a></li>
<li><a title="circus.circus.CircusGeomVec" href="#circus.circus.CircusGeomVec">CircusGeomVec</a></li>
<li><a title="circus.gym.op.OPGeomV0" href="gym/op.html#circus.gym.op.OPGeomV0">OPGeomV0</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="circus.circus.CircusGeom.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self, env_ids:Â listÂ =Â None) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Close all (parallel) ACE environment(s).</p>
<h2 id="arguments">Arguments</h2>
<p><code>env_ids</code>: List of environemt IDs that will be closed.
Default = None closes all.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self, env_ids: list[int] = None) -&gt; None:
    &#34;&#34;&#34;
    Close all (parallel) ACE environment(s).
    Arguments:
        `env_ids`: List of environemt IDs that will be closed.
                   Default = None closes all.
    &#34;&#34;&#34;
    for env_id in (env_ids or self.ace_envs.keys()):
        self.ace_envs[env_id].clear()</code></pre>
</details>
</dd>
<dt id="circus.circus.CircusGeom.env_is_wrapped"><code class="name flex">
<span>def <span class="ident">env_is_wrapped</span></span>(<span>self, wrapper_class:Â Type[gym.core.Wrapper], indices:Â Union[ForwardRef(None),Â int,Â Iterable[int]]Â =Â None) â€‘>Â List[bool]</span>
</code></dt>
<dd>
<div class="desc"><p>Check if environments are wrapped with a given wrapper.</p>
<p>:param method_name: The name of the environment method to invoke.
:param indices: Indices of envs whose method to call
:param method_args: Any positional arguments to provide in the call
:param method_kwargs: Any keyword arguments to provide in the call
:return: True if the env is wrapped, False otherwise, for each env queried.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def env_is_wrapped( self, wrapper_class: Type[gym.Wrapper]
                  , indices: VecEnvIndices = None) -&gt; List[bool]:
    return [False for _ in range(self.num_envs)]</code></pre>
</details>
</dd>
<dt id="circus.circus.CircusGeom.env_method"><code class="name flex">
<span>def <span class="ident">env_method</span></span>(<span>self, method_name:Â str, *method_args, indices:Â Union[ForwardRef(None),Â int,Â Iterable[int]]Â =Â None, **method_kwargs) â€‘>Â List[Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Call instance methods of vectorized environments.</p>
<p>:param method_name: The name of the environment method to invoke.
:param indices: Indices of envs whose method to call
:param method_args: Any positional arguments to provide in the call
:param method_kwargs: Any keyword arguments to provide in the call
:return: List of items returned by the environment's method call</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def env_method( self, method_name: str, *method_args
              , indices: VecEnvIndices = None, **method_kwargs
              ) -&gt; List[Any]:
    target_envs = self._get_target_envs(indices)
    return [ getattr(env_i, method_name)(*method_args, **method_kwargs)
             for env_i in target_envs ]</code></pre>
</details>
</dd>
<dt id="circus.circus.CircusGeom.get_attr"><code class="name flex">
<span>def <span class="ident">get_attr</span></span>(<span>self, attr_name:Â str, indices:Â Union[ForwardRef(None),Â int,Â Iterable[int]]Â =Â None) â€‘>Â List[Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Return attribute from vectorized environment.</p>
<p>:param attr_name: The name of the attribute whose value to return
:param indices: Indices of envs to get attribute from
:return: List of values of 'attr_name' in all environments</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attr( self, attr_name: str, indices: VecEnvIndices = None
            ) -&gt; List[Any]:
    target_envs = self._get_target_envs(indices)
    return [getattr(env_i, attr_name) for env_i in target_envs]</code></pre>
</details>
</dd>
<dt id="circus.circus.CircusGeom.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self, mode:Â strÂ =Â 'human') â€‘>Â Optional[numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc"><p>Renders the environment.</p>
<p>The set of supported modes varies per environment. (And some
environments do not support rendering at all.) By convention,
if mode is:</p>
<ul>
<li>human: render to the current display or terminal and
return nothing. Usually for human consumption.</li>
<li>rgb_array: Return an numpy.ndarray with shape (x, y, 3),
representing RGB values for an x-by-y pixel image, suitable
for turning into a video.</li>
<li>ansi: Return a string (str) or StringIO.StringIO containing a
terminal-style text representation. The text can include newlines
and ANSI escape sequences (e.g. for colors).</li>
</ul>
<h2 id="note">Note</h2>
<p>Make sure that your class's metadata 'render.modes' key includes
the list of supported modes. It's recommended to call super()
in implementations to use the functionality of this method.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mode</code></strong> :&ensp;<code>str</code></dt>
<dd>the mode to render with</dd>
</dl>
<p>Example:</p>
<p>class MyEnv(Env):
metadata = {'render.modes': ['human', 'rgb_array']}</p>
<pre><code>def render(self, mode='human'):
    if mode == 'rgb_array':
        return np.array(...) # return RGB frame suitable for video
    elif mode == 'human':
        ... # pop up a window and render
    else:
        super(MyEnv, self).render(mode=mode) # just raise an exception
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def render(self, mode: str = &#39;human&#39;) -&gt; Optional[np.ndarray]:
    pass</code></pre>
</details>
</dd>
<dt id="circus.circus.CircusGeom.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self, env_mask:Â [<classÂ 'bool'>]Â =Â [], env_ids:Â [<classÂ 'int'>]Â =Â [])</span>
</code></dt>
<dd>
<div class="desc"><p>Reset all (parallel) environemt(s).</p>
<h2 id="arguments">Arguments</h2>
<p><code>env_mask</code>: Boolean mask of environemts that will be reset. Passing
the <code>done</code> vector works. (Presendece)
<code>env_ids</code>: List of integer IDs of environemts that will be reset.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self, env_mask: [bool] = [], env_ids: [int] = []):
    &#34;&#34;&#34;
    Reset all (parallel) environemt(s).
    Arguments:
        `env_mask`: Boolean mask of environemts that will be reset. Passing
                    the `done` vector works. (Presendece)
        `env_ids`: List of integer IDs of environemts that will be reset.
    &#34;&#34;&#34;
    reset_ids     = [ i for i,m in enumerate(env_mask) if m
                    ] or env_ids or range(self.num_envs)
    pool          = { i: self.ace_envs[i] for i in reset_ids }
    random_sizing = ac.random_sizing_pool(pool)
    results       = ac.evaluate_circuit_pool(pool, pool_params = random_sizing)
    self.goal     = add_noise(self.reference_goal)
    state         = filter_results(self.obs_filter, results)
    achieved      = filter_results(self.goal_filter, results)
    observation   = OrderedDict({ &#39;observation&#39;:   ( self.obs_scaler(state)
                                                     if self.scale_observation
                                                     else state )
                                , &#39;achieved_goal&#39;: ( self.goal_scaler(achieved)
                                                     if self.scale_observation
                                                     else achieved )
                                , &#39;desired_goal&#39;:  ( self.goal_scaler(self.goal)
                                                     if self.scale_observation
                                                     else self.goal ) })

    self.steps[reset_ids] = 0

    return observation</code></pre>
</details>
</dd>
<dt id="circus.circus.CircusGeom.seed"><code class="name flex">
<span>def <span class="ident">seed</span></span>(<span>self, seed:Â Optional[int]Â =Â None) â€‘>Â List[Optional[int]]</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the seed for this env's random number generator(s).</p>
<h2 id="note">Note</h2>
<p>Some environments use multiple pseudorandom number generators.
We want to capture all such seeds used in order to ensure that
there aren't accidental correlations between multiple generators.</p>
<h2 id="returns">Returns</h2>
<p>list<bigint>: Returns the list of seeds used in this env's random
number generators. The first value in the list should be the
"main" seed, or the value which a reproducer should pass to
'seed'. Often, the main seed equals the provided 'seed', but
this won't be true if seed=None, for example.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def seed(self, seed: Optional[int] = None) -&gt; List[Union[None, int]]:
    self.rng_seed = seed
    return [self.rng_seed] * self.num_envs</code></pre>
</details>
</dd>
<dt id="circus.circus.CircusGeom.set_attr"><code class="name flex">
<span>def <span class="ident">set_attr</span></span>(<span>self, attr_name:Â str, value:Â Any, indices:Â Union[ForwardRef(None),Â int,Â Iterable[int]]Â =Â None) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Set attribute inside vectorized environments.</p>
<p>:param attr_name: The name of attribute to assign new value
:param value: Value to assign to <code>attr_name</code>
:param indices: Indices of envs to assign value
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_attr( self, attr_name: str, value: Any
            , indices: VecEnvIndices = None) -&gt; None:
    target_envs = self._get_target_envs(indices)
    for env_i in target_envs:
        setattr(env_i, attr_name, value)</code></pre>
</details>
</dd>
<dt id="circus.circus.CircusGeom.step"><code class="name flex">
<span>def <span class="ident">step</span></span>(<span>self, actions:Â numpy.ndarray) â€‘>Â Tuple[Union[numpy.ndarray,Â Dict[str,Â numpy.ndarray],Â Tuple[numpy.ndarray,Â ...]],Â numpy.ndarray,Â numpy.ndarray,Â List[Dict]]</span>
</code></dt>
<dd>
<div class="desc"><p>Take a step in the Environment. Calls <code>step_async</code> and <code>step_wait</code>
under the hood.</p>
<h2 id="arguments">Arguments</h2>
<p><code>actions</code>: Take Action with shape [num_envs, action_space].</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def step(self, actions: np.ndarray) -&gt; VecEnvStepReturn:
    &#34;&#34;&#34;
    Take a step in the Environment. Calls `step_async` and `step_wait`
    under the hood.
    Arguments:
        `actions`: Take Action with shape [num_envs, action_space].
    &#34;&#34;&#34;
    self.step_async(actions)
    return self.step_wait()</code></pre>
</details>
</dd>
<dt id="circus.circus.CircusGeom.step_async"><code class="name flex">
<span>def <span class="ident">step_async</span></span>(<span>self, actions:Â numpy.ndarray) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Initiate a step in the Environment. </p>
<h2 id="arguments">Arguments</h2>
<p><code>actions</code>: Take Action with shape [num_envs, action_space].</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def step_async(self, actions: np.ndarray) -&gt; None:
    &#34;&#34;&#34;
    Initiate a step in the Environment. 
    Arguments:
        `actions`: Take Action with shape [num_envs, action_space].
    &#34;&#34;&#34;
    unscaled    = list(self.unscale_action(actions))
    params      = sorted(ac.sizing_identifiers(self.ace_envs[0]))
    self.sizing = { env_id: dict(zip(params, action.tolist()))
                    for env_id,action in enumerate(unscaled)}</code></pre>
</details>
</dd>
<dt id="circus.circus.CircusGeom.step_wait"><code class="name flex">
<span>def <span class="ident">step_wait</span></span>(<span>self) â€‘>Â Tuple[Union[numpy.ndarray,Â Dict[str,Â numpy.ndarray],Â Tuple[numpy.ndarray,Â ...]],Â numpy.ndarray,Â numpy.ndarray,Â List[Dict]]</span>
</code></dt>
<dd>
<div class="desc"><p>Complete a step in the Environment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def step_wait(self) -&gt; VecEnvStepReturn:
    &#34;&#34;&#34;
    Complete a step in the Environment.
    &#34;&#34;&#34;
    pool        = { i: self.ace_envs[i] for i in range(self.num_envs) }
    results     = ac.evaluate_circuit_pool(pool, pool_params = self.sizing)

    state       = filter_results(self.obs_filter, results)
    achieved    = filter_results(self.goal_filter, results)

    observation = OrderedDict({ &#39;observation&#39;:   ( self.obs_scaler(state)
                                                   if self.scale_observation
                                                   else state )
                              , &#39;achieved_goal&#39;: ( self.goal_scaler(achieved)
                                                   if self.scale_observation
                                                   else achieved )
                              , &#39;desired_goal&#39;:  ( self.goal_scaler(self.goal)
                                                   if self.scale_observation
                                                   else self.goal ) })

    reward      = self.calculate_reward(observation)

    self.steps  = self.steps + 1

    done        = (reward == 0) | (self.steps &gt;= self.num_steps)

    info        = [{ &#39;outputs&#39;: self.obs_filter
                   , &#39;goal&#39;:    self.goal_filter
                   , &#39;inputs&#39;:  self.input_parameters
                   , }] * self.num_envs

    return (observation, reward, done, info)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="circus.circus.CircusGeomVec"><code class="flex name class">
<span>class <span class="ident">CircusGeomVec</span></span>
<span>(</span><span>reward_fn:Â CallableÂ =Â &lt;function dummy_reward&gt;, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Geometric Sizing Non-Goal Environment </p>
<p>Construct Geometric Sizing Non-Goal Environment. Same Arguments as
<code><a title="circus.circus.CircusGeom" href="#circus.circus.CircusGeom">CircusGeom</a></code> but different default <code>reward_fn</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CircusGeomVec(CircusGeom):
    &#34;&#34;&#34; Geometric Sizing Non-Goal Environment &#34;&#34;&#34;
    def __init__(self, reward_fn: Callable = dummy_reward, **kwargs):
        &#34;&#34;&#34;
        Construct Geometric Sizing Non-Goal Environment. Same Arguments as
        `CircusGeom` but different default `reward_fn`.
        &#34;&#34;&#34;
        super().__init__(**(kwargs | {&#39;reward_fn&#39;: reward_fn}))
        self.observation_space = self.observation_space[&#39;observation&#39;]

    def reset(self, **kwargs) -&gt; np.array:
        obs = super().reset(**kwargs)
        return obs[&#39;observation&#39;]

    def step_wait(self) -&gt; VecEnvStepReturn:
        obs, _, done, info = super().step_wait()
        observation        = obs[&#39;observation&#39;]
        reward             = self.calculate_reward(observation)
        return (observation, reward, done, info)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="circus.circus.CircusGeom" href="#circus.circus.CircusGeom">CircusGeom</a></li>
<li>gym.core.GoalEnv</li>
<li>gym.core.Env</li>
<li>stable_baselines3.common.vec_env.base_vec_env.VecEnv</li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="circus.gym.op.OPGeomV1" href="gym/op.html#circus.gym.op.OPGeomV1">OPGeomV1</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="circus.circus.CircusGeom" href="#circus.circus.CircusGeom">CircusGeom</a></b></code>:
<ul class="hlist">
<li><code><a title="circus.circus.CircusGeom.close" href="#circus.circus.CircusGeom.close">close</a></code></li>
<li><code><a title="circus.circus.CircusGeom.env_is_wrapped" href="#circus.circus.CircusGeom.env_is_wrapped">env_is_wrapped</a></code></li>
<li><code><a title="circus.circus.CircusGeom.env_method" href="#circus.circus.CircusGeom.env_method">env_method</a></code></li>
<li><code><a title="circus.circus.CircusGeom.get_attr" href="#circus.circus.CircusGeom.get_attr">get_attr</a></code></li>
<li><code><a title="circus.circus.CircusGeom.render" href="#circus.circus.CircusGeom.render">render</a></code></li>
<li><code><a title="circus.circus.CircusGeom.reset" href="#circus.circus.CircusGeom.reset">reset</a></code></li>
<li><code><a title="circus.circus.CircusGeom.seed" href="#circus.circus.CircusGeom.seed">seed</a></code></li>
<li><code><a title="circus.circus.CircusGeom.set_attr" href="#circus.circus.CircusGeom.set_attr">set_attr</a></code></li>
<li><code><a title="circus.circus.CircusGeom.step" href="#circus.circus.CircusGeom.step">step</a></code></li>
<li><code><a title="circus.circus.CircusGeom.step_async" href="#circus.circus.CircusGeom.step_async">step_async</a></code></li>
<li><code><a title="circus.circus.CircusGeom.step_wait" href="#circus.circus.CircusGeom.step_wait">step_wait</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="circus" href="index.html">circus</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="circus.circus.make" href="#circus.circus.make">make</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="circus.circus.CircusElec" href="#circus.circus.CircusElec">CircusElec</a></code></h4>
</li>
<li>
<h4><code><a title="circus.circus.CircusElecVec" href="#circus.circus.CircusElecVec">CircusElecVec</a></code></h4>
</li>
<li>
<h4><code><a title="circus.circus.CircusGeom" href="#circus.circus.CircusGeom">CircusGeom</a></code></h4>
<ul class="two-column">
<li><code><a title="circus.circus.CircusGeom.close" href="#circus.circus.CircusGeom.close">close</a></code></li>
<li><code><a title="circus.circus.CircusGeom.env_is_wrapped" href="#circus.circus.CircusGeom.env_is_wrapped">env_is_wrapped</a></code></li>
<li><code><a title="circus.circus.CircusGeom.env_method" href="#circus.circus.CircusGeom.env_method">env_method</a></code></li>
<li><code><a title="circus.circus.CircusGeom.get_attr" href="#circus.circus.CircusGeom.get_attr">get_attr</a></code></li>
<li><code><a title="circus.circus.CircusGeom.render" href="#circus.circus.CircusGeom.render">render</a></code></li>
<li><code><a title="circus.circus.CircusGeom.reset" href="#circus.circus.CircusGeom.reset">reset</a></code></li>
<li><code><a title="circus.circus.CircusGeom.seed" href="#circus.circus.CircusGeom.seed">seed</a></code></li>
<li><code><a title="circus.circus.CircusGeom.set_attr" href="#circus.circus.CircusGeom.set_attr">set_attr</a></code></li>
<li><code><a title="circus.circus.CircusGeom.step" href="#circus.circus.CircusGeom.step">step</a></code></li>
<li><code><a title="circus.circus.CircusGeom.step_async" href="#circus.circus.CircusGeom.step_async">step_async</a></code></li>
<li><code><a title="circus.circus.CircusGeom.step_wait" href="#circus.circus.CircusGeom.step_wait">step_wait</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="circus.circus.CircusGeomVec" href="#circus.circus.CircusGeomVec">CircusGeomVec</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>