<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>circus.circus API documentation</title>
<meta name="description" content="Gym compatible Analog Circuit Environment" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>circus.circus</code></h1>
</header>
<section id="section-intro">
<p>Gym compatible Analog Circuit Environment</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34; Gym compatible Analog Circuit Environment &#34;&#34;&#34;

import os
from functools import partial
from collections import OrderedDict
from typing import Any, List, Optional, Type, Union, Callable, Mapping
import gym
from gym.spaces import Dict, Box
from gym import GoalEnv
from stable_baselines3.common.vec_env.base_vec_env import VecEnv, \
                                                          VecEnvIndices, \
                                                          VecEnvStepReturn
import json
import numpy as np
import hace as ac

from .util   import *
from .reward import *
from .ace    import *
from .prim   import *
from .trafo  import *

class CircusGeom(GoalEnv, VecEnv):
    &#34;&#34;&#34; Geometric Sizing Goal Environment &#34;&#34;&#34;
    def __init__( self
                , ace_id: str
                , ace_backend: str
                , num_envs: int                    = 1
                , num_steps: int                   = 50
                , seed: int                        = 666
                , obs_filter: Union[str,List[str]] = &#39;perf&#39;
                , goal_filter: list[str]           = None
                , goal_preds: list[Callable]       = None
                , goal_init: Union[str,np.ndarray] = &#39;noisy&#39;
                , reward_fn: Callable              = None
                , scale_observation: bool          = True
                , auto_reset: bool                 = False
                , ):
        &#34;&#34;&#34;
        Construct a Geometric Sizing Goal Environment
        Arguments:
            `ace_id`:            ID of the form &#39;op#&#39;, see ACE Documentation for further
                                 details.
            `ace_backend`:       PDK, available are &#39;xh035&#39; and &#39;xh018&#39;.
            `num_envs`:          Numer of Parallel Environments âˆˆ [ 1 .. `nproc` ]
            `num_steps`:         Number of steps per Episode.
            `seed`:              Random Seed
            `obs_filter`:        Filter Performance dict obtained from ACE:
                                 &#39;perf&#39;: Only performance paramters (default)
                                 &#39;all&#39;: All parameters from ACE
                                 [str]: List of parameters
            `goal_filter`:       List of parameters
            `goal_preds`:        Binary comparison operator
            `goal_init`:         How to initialize new goals on reset:
                                 &#39;noisy&#39;: Put some noise on a reference goal (default)
                                 &#39;random&#39;: Choose a point in goal space
                                 np.ndarray: A specific goal of shape
                                 (num_envs, len(goal_filter))
            `reward_fn`:         Optional reward function that takes an observation dict.
            `scale_observation`: Scale the observations and goals as specified in trafo
            `auto_reset`:        Automatically reset environemt when done.
        &#34;&#34;&#34;

        self.ace_id: str       = ace_id
        self.ace_backend: str  = ace_backend
        self.num_envs: int     = num_envs

        self.auto_reset: bool  = auto_reset

        self.num_steps: int    = num_steps
        self.steps: np.array   = np.zeros(num_envs)

        self.ace_envs          = ac.make_same_env_pool( self.num_envs
                                                      , self.ace_id
                                                      , self.ace_backend )

        self.constraints       = ac.parameter_dict(self.ace_envs[0])

        const_params           = { k: v[&#39;init&#39;]
                                   for k,v in self.constraints.items()
                                   if not v[&#39;sizing&#39;] }

        ac.set_parameters_pool( self.ace_envs
                              , { i: const_params
                                  for i in range(self.num_envs) }
                              , )

        perf_ids               = sorted(ac.performance_identifiers(self.ace_envs[0]))
        self.obs_filter        = ( perf_ids if obs_filter == &#39;all&#39; else
                                   [p for p in perf_ids
                                      if (p.islower() or (p == &#39;A&#39;)
                                                      or (p.startswith(&#39;vn_&#39;)))]
                                   if obs_filter == &#39;perf&#39; else
                                   obs_filter if isinstance(obs_filter, list)
                                   else ValueError(&#39;Wrong Argument type passed to obs_filter.&#39;) )
        self.obs_idx           = np.array([ i for i,p in enumerate(self.obs_filter)
                                            if p in self.obs_filter ])

        self.obs_scaler,\
        self.obs_unscaler      = performance_scaler( self.ace_id
                                                   , self.ace_backend
                                                   , self.constraints
                                                   , self.obs_filter
                                                   , )

        self.input_parameters  = ac.sizing_identifiers(self.ace_envs[0])

        self.goal_filter       = goal_filter or [ ident for ident in self.obs_filter
                                                  if ident.islower() or (ident == &#39;A&#39;) ]

        self.goal_idx          = np.array([i for i,p in enumerate(self.obs_filter)
                                             if p in self.goal_filter])

        self.goal_preds        = goal_preds or goal_predicate(self.goal_filter)

        self.goal_scaler, \
        self.goal_unscaler     = performance_scaler( self.ace_id
                                                   , self.ace_backend
                                                   , self.constraints
                                                   , self.goal_filter
                                                   , )

        self.calculate_reward  = reward_fn or partial(binary_reward, self.goal_preds)

        self.action_space      = Box( low   = -1.0
                                    , high  = 1.0
                                    , shape = (len(self.input_parameters),)
                                    , dtype = np.float32 )

        self.observation_space = Dict({ &#39;observation&#39;:   Box( -np.Inf, np.Inf
                                                            , (len(self.obs_filter),))
                                      , &#39;achieved_goal&#39;: Box( -np.Inf, np.Inf
                                                            , (len(self.goal_filter),))
                                      , &#39;desired_goal&#39;:  Box( -np.Inf, np.Inf
                                                            , (len(self.goal_filter),))
                                      , })

        self.scale_observation = scale_observation

        self.rng_seed          = seed

        reference              = ac.evaluate_circuit_pool(self.ace_envs)[0]

        if isinstance(goal_init, str) and goal_init == &#39;noisy&#39;:
            self.goal_init      = goal_init
            ref_goal_op         = reference_goal( self.ace_id, self.ace_backend
                                                , self.constraints )
            ref_goal            = { gf: ref_goal_op.get(gf, reference[gf])
                                    for gf in self.goal_filter }
            ref_goals           = { i: ref_goal for i in range(self.num_envs) }

            self.reference_goal = filter_results( self.goal_filter
                                                , ref_goals )
        elif isinstance(goal_init, str) and goal_init == &#39;random&#39;:
            self.goal_init      = goal_init
            x_min_d, x_max_d    = performance_scale( self.ace_id
                                                   , self.ace_backend
                                                   , self.constraints
                                                   , )
            self.reference_goal = np.array([ [x_min_d[gp] for gp in self.goal_filter]
                                           , [x_max_d[gp] for gp in self.goal_filter]
                                           ])
        elif isinstance(goal_init, np.ndarray):
            self.goal_init      = &#39;fix&#39;
            goal_shape          = (num_envs, len(self.goal_filter))
            self.reference_goal = ( goal_init
                                    if goal_init.shape == goal_shape else
                                    np.repeat(goal_init[None], num_envs, axis = 0) )
        else:
            NotImplementedError(f&#39;Goal initializer {goal_init} not available.&#39;)

        self.new_goal          = goal_generator( self.goal_init
                                               , self.reference_goal
                                               , self.num_envs
                                               , )
        self.goal              = self.new_goal()

        self.act_unscaler      = geometric_unscaler(self.constraints)

        self.sizing            = {}

        VecEnv.__init__( self, self.num_envs
                       , self.observation_space
                       , self.action_space )

    def close(self, env_ids: list[int] = None) -&gt; None:
        &#34;&#34;&#34;
        Close all (parallel) ACE environment(s).
        Arguments:
            `env_ids`: List of environment IDs that will be closed.
                       Default = None closes all.
        &#34;&#34;&#34;
        for env_id in (env_ids or self.ace_envs.keys()):
            self.ace_envs[env_id].clear()

    def observation_dict( self, observation: dict[int, dict[str, float]]
                        ) -&gt; dict[str, np.ndarray]:
        &#34;&#34;&#34;
        Takes an observation from a pooled ACE Environment and returns a
        GoalEnv compliant OrderedDict.
        &#34;&#34;&#34;
        state       = filter_results(self.obs_filter, observation)
        achieved    = filter_results(self.goal_filter, observation)

        obs         = np.nan_to_num( self.obs_scaler(state)
                                     if self.scale_observation else state )
        a_goal      = np.nan_to_num( self.goal_scaler(achieved)
                                     if self.scale_observation else achieved )
        d_goal      = np.nan_to_num( self.goal_scaler(self.goal)
                                     if self.scale_observation else self.goal )

        return OrderedDict({ &#39;observation&#39;:   obs
                           , &#39;achieved_goal&#39;: a_goal
                           , &#39;desired_goal&#39;:  d_goal })

    def reset(self, env_mask: list[bool] = [], env_ids: list[int] = []):
        &#34;&#34;&#34;
        Reset all (parallel) environment(s).
        Arguments:
            `env_mask`: Boolean mask of environemts that will be reset. Passing
                        the `done` vector works. This argument is prioritized
                        over `env_ids`.
            `env_ids`: List of integer IDs of environments that will be reset.
                       This argument is discarded in favour of `env_mask`.
        &#34;&#34;&#34;

        previous              = ac.current_performance_pool(self.ace_envs)
        prev_obs              = self.observation_dict(previous)
        state                 = prev_obs[&#39;observation&#39;]
        achieved              = prev_obs[&#39;achieved_goal&#39;]

        reset_ids             = [ i for i,m in enumerate(env_mask) if m
                                ] or env_ids or range(self.num_envs)

        pool                  = { i: self.ace_envs[i] for i in reset_ids }
        random_sizing         = ac.random_sizing_pool(pool)
        results               = ac.evaluate_circuit_pool( pool
                                                        , pool_params = random_sizing
                                                        , )

        observation           = self.observation_dict(results)

        state[reset_ids]      = observation[&#39;observation&#39;]
        achieved[reset_ids]   = observation[&#39;achieved_goal&#39;]

        self.goal[reset_ids]  = self.new_goal()[reset_ids]

        goal                  = ( self.goal_scaler(self.goal)
                                  if self.scale_observation else
                                  self.goal )

        self.steps[reset_ids] = 0

        return OrderedDict({ &#39;observation&#39;:   state
                           , &#39;achieved_goal&#39;: achieved
                           , &#39;desired_goal&#39;:  goal })

    def step(self, actions: np.ndarray) -&gt; VecEnvStepReturn:
        &#34;&#34;&#34;
        Take a step in the Environment. Calls `step_async` and `step_wait`
        under the hood.
        Arguments:
            `actions`: Take Action with shape [num_envs, action_space].
        &#34;&#34;&#34;
        self.step_async(actions)
        return self.step_wait()

    def step_async(self, actions: np.ndarray) -&gt; None:
        &#34;&#34;&#34;
        Initiate a step in the Environment.
        Arguments:
            `actions`: Take Action with shape [num_envs, action_space].
        &#34;&#34;&#34;

        unscaled    = self.act_unscaler(np.clip( actions
                                               , self.action_space.low
                                               , self.action_space.high ))
        params      = sorted(ac.sizing_identifiers(self.ace_envs[0]))
        self.sizing = { env_id: dict(zip(params, action.tolist()))
                        for env_id,action in enumerate(list(unscaled))}

    def step_wait(self) -&gt; VecEnvStepReturn:
        &#34;&#34;&#34;
        Complete a step in the Environment.
        &#34;&#34;&#34;
        pool        = { i: self.ace_envs[i] for i in range(self.num_envs) }
        results     = ac.evaluate_circuit_pool(pool, pool_params = self.sizing)

        observation = self.observation_dict(results)

        reward      = self.calculate_reward(observation)

        self.steps  = self.steps + 1

        done        = (reward == 0) | (self.steps &gt;= self.num_steps)

        info_dict   = { &#39;outputs&#39;: self.obs_filter
                      , &#39;goal&#39;:    self.goal_filter
                      , &#39;inputs&#39;:  self.input_parameters
                      , }

        info        = [ info_dict | {&#39;is_success&#39;: s} for s in (reward == 0).tolist() ]

        if self.auto_reset and done.any():
            for i in range(len(info)):
                info[i][&#34;terminal_obs&#34;] = observation[&#34;observation&#34;][i]
                info[i][&#34;target&#34;] = observation[&#34;desired_goal&#34;][i]
            observation = self.reset(done)

        return (observation, reward, done, info)

    def compute_reward( self, achieved_goal: object, desired_goal: object
                      , info: Mapping[str, Any] ) -&gt; np.array:
        &#34;&#34;&#34;
        Externalized reward calculation for stable baselines compatibility.
        Calls `self.calculate_reward` under the hood.
        &#34;&#34;&#34;
        observation = { &#34;achieved_goal&#34;: achieved_goal
                      , &#34;desired_goal&#34;:  desired_goal
                      , }
        return self.calculate_reward(observation = observation)

    def get_attr( self, attr_name: str, indices: VecEnvIndices = None
                ) -&gt; List[Any]:
        target_envs = self._get_target_envs(indices)
        return [getattr(env_i, attr_name) for env_i in target_envs]

    def set_attr( self, attr_name: str, value: Any
                , indices: VecEnvIndices = None) -&gt; None:
        target_envs = self._get_target_envs(indices)
        for env_i in target_envs:
            setattr(env_i, attr_name, value)

    def env_method( self, method_name: str, *method_args
                  , indices: VecEnvIndices = None, **method_kwargs
                  ) -&gt; List[Any]:
        target_envs = self._get_target_envs(indices)
        return [ getattr(env_i, method_name)(*method_args, **method_kwargs)
                 for env_i in target_envs ]

    def env_is_wrapped( self, wrapper_class: Type[gym.Wrapper]
                      , indices: VecEnvIndices = None) -&gt; List[bool]:
        return [False for _ in range(self.num_envs)]

    def _get_target_envs(self, indices: VecEnvIndices) -&gt; List[gym.Env]:
        return [self]

    def seed(self, seed: Optional[int] = None) -&gt; List[Union[None, int]]:
        self.rng_seed = seed
        return [self.rng_seed] * self.num_envs

    def render(self, mode: str = &#39;human&#39;) -&gt; Optional[np.ndarray]:
        pass

class CircusElec(CircusGeom):
    &#34;&#34;&#34; Electric Sizing Goal Environment &#34;&#34;&#34;
    def __init__(self, **kwargs):
        &#34;&#34;&#34;
        Construct Electric Sizing Goal Environment. Same Arguments as
        `CircusGeom`.
        &#34;&#34;&#34;
        super().__init__(**kwargs)

        nmos_path = os.path.expanduser(f&#39;~/.ace/{self.ace_backend}/nmos&#39;)
        pmos_path = os.path.expanduser(f&#39;~/.ace/{self.ace_backend}/pmos&#39;)
        params_x  = [&#39;gmoverid&#39;, &#39;fug&#39;, &#39;Vds&#39;, &#39;Vbs&#39;]
        params_y  = [&#39;idoverw&#39;, &#39;L&#39;, &#39;gdsoverw&#39;, &#39;Vgs&#39;]
        trafo_x   = [&#39;fug&#39;]
        trafo_y   = [&#39;idoverw&#39;, &#39;gdsoverw&#39;]
        self.nmos = PrimitiveDevice(nmos_path, params_x, params_y, trafo_x, trafo_y)
        self.pmos = PrimitiveDevice(pmos_path, params_x, params_y, trafo_x, trafo_y)

        self.transformation = partial( transformation(self.ace_id)
                                     , self.constraints
                                     , self.nmos
                                     , self.pmos
                                     , )

        self.input_parameters  = electric_identifiers(self.ace_id)

        self.action_space      = Box( low   = -1.0
                                    , high  = 1.0
                                    , shape = (len(self.input_parameters),)
                                    , dtype = np.float32 )

        self.act_unscaler      = electric_unscaler(self.ace_id, self.ace_backend)

    def step_async(self, actions: np.ndarray) -&gt; None:
        unscaled    = self.act_unscaler(np.clip( actions
                                               , self.action_space.low
                                               , self.action_space.high ))

        self.sizing = { env_id: self.transformation(* action.tolist())
                        for env_id,action in enumerate(list(unscaled)) }

class CircusGeomVec(CircusGeom):
    &#34;&#34;&#34; Geometric Sizing Non-Goal Environment &#34;&#34;&#34;
    def __init__(self, reward_fn: Callable = dummy_reward, **kwargs):
        &#34;&#34;&#34;
        Construct Geometric Sizing Non-Goal Environment. Same Arguments as
        `CircusGeom` but different default `reward_fn`.
        &#34;&#34;&#34;
        super().__init__(**(kwargs | {&#39;reward_fn&#39;: reward_fn}))
        self.observation_space = self.observation_space[&#39;observation&#39;]

    def reset(self, **kwargs) -&gt; np.array:
        obs = super().reset(**kwargs)
        return obs[&#39;observation&#39;]

    def step_wait(self) -&gt; VecEnvStepReturn:
        obs, reward, done, info = super().step_wait()
        observation        = obs[&#39;observation&#39;]
        return (observation, reward, done, info)

class CircusElecVec(CircusElec):
    &#34;&#34;&#34; Geometric Sizing Non-Goal Environment &#34;&#34;&#34;
    def __init__(self, reward_fn: Callable = dummy_reward, **kwargs):
        &#34;&#34;&#34;
        Construct Geometric Sizing Non-Goal Environment. Same Arguments as
        `CircusElec`.
        &#34;&#34;&#34;
        super().__init__(**(kwargs | {&#39;reward_fn&#39;: reward_fn}))
        self.observation_space = self.observation_space[&#39;observation&#39;]

    def reset(self, **kwargs) -&gt; np.array:
        obs = super().reset(**kwargs)
        return obs[&#39;observation&#39;]

    def step_wait(self) -&gt; VecEnvStepReturn:
        obs, reward, done, info = super().step_wait()
        observation        = obs[&#39;observation&#39;]
        return (observation, reward, done, info)

def make( env_id: str, n_envs: int = 1, **kwargs
        ) -&gt; Union[CircusGeom, CircusGeomVec]:
    &#34;&#34;&#34;
    Gym Style Environment Constructor, see `gym.make`.
    Arguments:
        `env_id`: Environment ID of the form &#39;&lt;ace id&gt;-&lt;pdk&gt;-&lt;space&gt;-v&lt;var&gt;
        `n_envs`: Number of Environment
        `kwargs`: Will be passed to Circus constructor.
    &#34;&#34;&#34;
    eid,pdk,spc,var = env_id.split(&#39;:&#39;)[1].split(&#39;-&#39;)
    backend = backend_id(pdk)

    env     = ( CircusGeom( ace_id      = eid
                          , ace_backend = backend
                          , num_envs    = n_envs
                          , **kwargs
                          )    if (var == &#39;v0&#39; and spc == &#39;geom&#39;) else
                CircusGeomVec( ace_id      = eid
                             , ace_backend = backend
                             , num_envs    = n_envs
                             , **kwargs
                             ) if (var == &#39;v1&#39; and spc == &#39;geom&#39;) else
                CircusElec( ace_id      = eid
                          , ace_backend = backend
                          , num_envs    = n_envs
                          , **kwargs
                          )    if (var == &#39;v0&#39; and spc == &#39;elec&#39;) else
                CircusElecVec( ace_id      = eid
                             , ace_backend = backend
                             , num_envs    = n_envs
                             , **kwargs
                             ) if (var == &#39;v1&#39; and spc == &#39;elec&#39;) else
                NotImplementedError(f&#39;Variant {var} not available&#39;) )
    return env</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="circus.circus.make"><code class="name flex">
<span>def <span class="ident">make</span></span>(<span>env_id:Â str, n_envs:Â intÂ =Â 1, **kwargs) â€‘>Â Union[<a title="circus.circus.CircusGeom" href="#circus.circus.CircusGeom">CircusGeom</a>,Â <a title="circus.circus.CircusGeomVec" href="#circus.circus.CircusGeomVec">CircusGeomVec</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Gym Style Environment Constructor, see <code>gym.make</code>.</p>
<h2 id="arguments">Arguments</h2>
<p><code>env_id</code>: Environment ID of the form '<ace id>-<pdk>-<space>-v<var>
<code>n_envs</code>: Number of Environment
<code>kwargs</code>: Will be passed to Circus constructor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make( env_id: str, n_envs: int = 1, **kwargs
        ) -&gt; Union[CircusGeom, CircusGeomVec]:
    &#34;&#34;&#34;
    Gym Style Environment Constructor, see `gym.make`.
    Arguments:
        `env_id`: Environment ID of the form &#39;&lt;ace id&gt;-&lt;pdk&gt;-&lt;space&gt;-v&lt;var&gt;
        `n_envs`: Number of Environment
        `kwargs`: Will be passed to Circus constructor.
    &#34;&#34;&#34;
    eid,pdk,spc,var = env_id.split(&#39;:&#39;)[1].split(&#39;-&#39;)
    backend = backend_id(pdk)

    env     = ( CircusGeom( ace_id      = eid
                          , ace_backend = backend
                          , num_envs    = n_envs
                          , **kwargs
                          )    if (var == &#39;v0&#39; and spc == &#39;geom&#39;) else
                CircusGeomVec( ace_id      = eid
                             , ace_backend = backend
                             , num_envs    = n_envs
                             , **kwargs
                             ) if (var == &#39;v1&#39; and spc == &#39;geom&#39;) else
                CircusElec( ace_id      = eid
                          , ace_backend = backend
                          , num_envs    = n_envs
                          , **kwargs
                          )    if (var == &#39;v0&#39; and spc == &#39;elec&#39;) else
                CircusElecVec( ace_id      = eid
                             , ace_backend = backend
                             , num_envs    = n_envs
                             , **kwargs
                             ) if (var == &#39;v1&#39; and spc == &#39;elec&#39;) else
                NotImplementedError(f&#39;Variant {var} not available&#39;) )
    return env</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="circus.circus.CircusElec"><code class="flex name class">
<span>class <span class="ident">CircusElec</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Electric Sizing Goal Environment </p>
<p>Construct Electric Sizing Goal Environment. Same Arguments as
<code><a title="circus.circus.CircusGeom" href="#circus.circus.CircusGeom">CircusGeom</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CircusElec(CircusGeom):
    &#34;&#34;&#34; Electric Sizing Goal Environment &#34;&#34;&#34;
    def __init__(self, **kwargs):
        &#34;&#34;&#34;
        Construct Electric Sizing Goal Environment. Same Arguments as
        `CircusGeom`.
        &#34;&#34;&#34;
        super().__init__(**kwargs)

        nmos_path = os.path.expanduser(f&#39;~/.ace/{self.ace_backend}/nmos&#39;)
        pmos_path = os.path.expanduser(f&#39;~/.ace/{self.ace_backend}/pmos&#39;)
        params_x  = [&#39;gmoverid&#39;, &#39;fug&#39;, &#39;Vds&#39;, &#39;Vbs&#39;]
        params_y  = [&#39;idoverw&#39;, &#39;L&#39;, &#39;gdsoverw&#39;, &#39;Vgs&#39;]
        trafo_x   = [&#39;fug&#39;]
        trafo_y   = [&#39;idoverw&#39;, &#39;gdsoverw&#39;]
        self.nmos = PrimitiveDevice(nmos_path, params_x, params_y, trafo_x, trafo_y)
        self.pmos = PrimitiveDevice(pmos_path, params_x, params_y, trafo_x, trafo_y)

        self.transformation = partial( transformation(self.ace_id)
                                     , self.constraints
                                     , self.nmos
                                     , self.pmos
                                     , )

        self.input_parameters  = electric_identifiers(self.ace_id)

        self.action_space      = Box( low   = -1.0
                                    , high  = 1.0
                                    , shape = (len(self.input_parameters),)
                                    , dtype = np.float32 )

        self.act_unscaler      = electric_unscaler(self.ace_id, self.ace_backend)

    def step_async(self, actions: np.ndarray) -&gt; None:
        unscaled    = self.act_unscaler(np.clip( actions
                                               , self.action_space.low
                                               , self.action_space.high ))

        self.sizing = { env_id: self.transformation(* action.tolist())
                        for env_id,action in enumerate(list(unscaled)) }</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="circus.circus.CircusGeom" href="#circus.circus.CircusGeom">CircusGeom</a></li>
<li>gym.core.GoalEnv</li>
<li>gym.core.Env</li>
<li>stable_baselines3.common.vec_env.base_vec_env.VecEnv</li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="circus.circus.CircusElecVec" href="#circus.circus.CircusElecVec">CircusElecVec</a></li>
<li><a title="circus.gym.op.OPElecV0" href="gym/op.html#circus.gym.op.OPElecV0">OPElecV0</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="circus.circus.CircusGeom" href="#circus.circus.CircusGeom">CircusGeom</a></b></code>:
<ul class="hlist">
<li><code><a title="circus.circus.CircusGeom.close" href="#circus.circus.CircusGeom.close">close</a></code></li>
<li><code><a title="circus.circus.CircusGeom.compute_reward" href="#circus.circus.CircusGeom.compute_reward">compute_reward</a></code></li>
<li><code><a title="circus.circus.CircusGeom.env_is_wrapped" href="#circus.circus.CircusGeom.env_is_wrapped">env_is_wrapped</a></code></li>
<li><code><a title="circus.circus.CircusGeom.env_method" href="#circus.circus.CircusGeom.env_method">env_method</a></code></li>
<li><code><a title="circus.circus.CircusGeom.get_attr" href="#circus.circus.CircusGeom.get_attr">get_attr</a></code></li>
<li><code><a title="circus.circus.CircusGeom.observation_dict" href="#circus.circus.CircusGeom.observation_dict">observation_dict</a></code></li>
<li><code><a title="circus.circus.CircusGeom.render" href="#circus.circus.CircusGeom.render">render</a></code></li>
<li><code><a title="circus.circus.CircusGeom.reset" href="#circus.circus.CircusGeom.reset">reset</a></code></li>
<li><code><a title="circus.circus.CircusGeom.seed" href="#circus.circus.CircusGeom.seed">seed</a></code></li>
<li><code><a title="circus.circus.CircusGeom.set_attr" href="#circus.circus.CircusGeom.set_attr">set_attr</a></code></li>
<li><code><a title="circus.circus.CircusGeom.step" href="#circus.circus.CircusGeom.step">step</a></code></li>
<li><code><a title="circus.circus.CircusGeom.step_async" href="#circus.circus.CircusGeom.step_async">step_async</a></code></li>
<li><code><a title="circus.circus.CircusGeom.step_wait" href="#circus.circus.CircusGeom.step_wait">step_wait</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="circus.circus.CircusElecVec"><code class="flex name class">
<span>class <span class="ident">CircusElecVec</span></span>
<span>(</span><span>reward_fn:Â CallableÂ =Â &lt;function dummy_reward&gt;, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Geometric Sizing Non-Goal Environment </p>
<p>Construct Geometric Sizing Non-Goal Environment. Same Arguments as
<code><a title="circus.circus.CircusElec" href="#circus.circus.CircusElec">CircusElec</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CircusElecVec(CircusElec):
    &#34;&#34;&#34; Geometric Sizing Non-Goal Environment &#34;&#34;&#34;
    def __init__(self, reward_fn: Callable = dummy_reward, **kwargs):
        &#34;&#34;&#34;
        Construct Geometric Sizing Non-Goal Environment. Same Arguments as
        `CircusElec`.
        &#34;&#34;&#34;
        super().__init__(**(kwargs | {&#39;reward_fn&#39;: reward_fn}))
        self.observation_space = self.observation_space[&#39;observation&#39;]

    def reset(self, **kwargs) -&gt; np.array:
        obs = super().reset(**kwargs)
        return obs[&#39;observation&#39;]

    def step_wait(self) -&gt; VecEnvStepReturn:
        obs, reward, done, info = super().step_wait()
        observation        = obs[&#39;observation&#39;]
        return (observation, reward, done, info)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="circus.circus.CircusElec" href="#circus.circus.CircusElec">CircusElec</a></li>
<li><a title="circus.circus.CircusGeom" href="#circus.circus.CircusGeom">CircusGeom</a></li>
<li>gym.core.GoalEnv</li>
<li>gym.core.Env</li>
<li>stable_baselines3.common.vec_env.base_vec_env.VecEnv</li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="circus.gym.op.OPElecV1" href="gym/op.html#circus.gym.op.OPElecV1">OPElecV1</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="circus.circus.CircusElec" href="#circus.circus.CircusElec">CircusElec</a></b></code>:
<ul class="hlist">
<li><code><a title="circus.circus.CircusElec.close" href="#circus.circus.CircusGeom.close">close</a></code></li>
<li><code><a title="circus.circus.CircusElec.compute_reward" href="#circus.circus.CircusGeom.compute_reward">compute_reward</a></code></li>
<li><code><a title="circus.circus.CircusElec.env_is_wrapped" href="#circus.circus.CircusGeom.env_is_wrapped">env_is_wrapped</a></code></li>
<li><code><a title="circus.circus.CircusElec.env_method" href="#circus.circus.CircusGeom.env_method">env_method</a></code></li>
<li><code><a title="circus.circus.CircusElec.get_attr" href="#circus.circus.CircusGeom.get_attr">get_attr</a></code></li>
<li><code><a title="circus.circus.CircusElec.observation_dict" href="#circus.circus.CircusGeom.observation_dict">observation_dict</a></code></li>
<li><code><a title="circus.circus.CircusElec.render" href="#circus.circus.CircusGeom.render">render</a></code></li>
<li><code><a title="circus.circus.CircusElec.reset" href="#circus.circus.CircusGeom.reset">reset</a></code></li>
<li><code><a title="circus.circus.CircusElec.seed" href="#circus.circus.CircusGeom.seed">seed</a></code></li>
<li><code><a title="circus.circus.CircusElec.set_attr" href="#circus.circus.CircusGeom.set_attr">set_attr</a></code></li>
<li><code><a title="circus.circus.CircusElec.step" href="#circus.circus.CircusGeom.step">step</a></code></li>
<li><code><a title="circus.circus.CircusElec.step_async" href="#circus.circus.CircusGeom.step_async">step_async</a></code></li>
<li><code><a title="circus.circus.CircusElec.step_wait" href="#circus.circus.CircusGeom.step_wait">step_wait</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="circus.circus.CircusGeom"><code class="flex name class">
<span>class <span class="ident">CircusGeom</span></span>
<span>(</span><span>ace_id:Â str, ace_backend:Â str, num_envs:Â intÂ =Â 1, num_steps:Â intÂ =Â 50, seed:Â intÂ =Â 666, obs_filter:Â Union[str,Â List[str]]Â =Â 'perf', goal_filter:Â list[str]Â =Â None, goal_preds:Â list[typing.Callable]Â =Â None, goal_init:Â Union[str,Â numpy.ndarray]Â =Â 'noisy', reward_fn:Â CallableÂ =Â None, scale_observation:Â boolÂ =Â True, auto_reset:Â boolÂ =Â False)</span>
</code></dt>
<dd>
<div class="desc"><p>Geometric Sizing Goal Environment </p>
<p>Construct a Geometric Sizing Goal Environment</p>
<h2 id="arguments">Arguments</h2>
<p><code>ace_id</code>:
ID of the form 'op#', see ACE Documentation for further
details.
<code>ace_backend</code>:
PDK, available are 'xh035' and 'xh018'.
<code>num_envs</code>:
Numer of Parallel Environments âˆˆ [ 1 .. <code>nproc</code> ]
<code>num_steps</code>:
Number of steps per Episode.
<code>seed</code>:
Random Seed
<code>obs_filter</code>:
Filter Performance dict obtained from ACE:
'perf': Only performance paramters (default)
'all': All parameters from ACE
[str]: List of parameters
<code>goal_filter</code>:
List of parameters
<code>goal_preds</code>:
Binary comparison operator
<code>goal_init</code>:
How to initialize new goals on reset:
'noisy': Put some noise on a reference goal (default)
'random': Choose a point in goal space
np.ndarray: A specific goal of shape
(num_envs, len(goal_filter))
<code>reward_fn</code>:
Optional reward function that takes an observation dict.
<code>scale_observation</code>: Scale the observations and goals as specified in trafo
<code>auto_reset</code>:
Automatically reset environemt when done.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CircusGeom(GoalEnv, VecEnv):
    &#34;&#34;&#34; Geometric Sizing Goal Environment &#34;&#34;&#34;
    def __init__( self
                , ace_id: str
                , ace_backend: str
                , num_envs: int                    = 1
                , num_steps: int                   = 50
                , seed: int                        = 666
                , obs_filter: Union[str,List[str]] = &#39;perf&#39;
                , goal_filter: list[str]           = None
                , goal_preds: list[Callable]       = None
                , goal_init: Union[str,np.ndarray] = &#39;noisy&#39;
                , reward_fn: Callable              = None
                , scale_observation: bool          = True
                , auto_reset: bool                 = False
                , ):
        &#34;&#34;&#34;
        Construct a Geometric Sizing Goal Environment
        Arguments:
            `ace_id`:            ID of the form &#39;op#&#39;, see ACE Documentation for further
                                 details.
            `ace_backend`:       PDK, available are &#39;xh035&#39; and &#39;xh018&#39;.
            `num_envs`:          Numer of Parallel Environments âˆˆ [ 1 .. `nproc` ]
            `num_steps`:         Number of steps per Episode.
            `seed`:              Random Seed
            `obs_filter`:        Filter Performance dict obtained from ACE:
                                 &#39;perf&#39;: Only performance paramters (default)
                                 &#39;all&#39;: All parameters from ACE
                                 [str]: List of parameters
            `goal_filter`:       List of parameters
            `goal_preds`:        Binary comparison operator
            `goal_init`:         How to initialize new goals on reset:
                                 &#39;noisy&#39;: Put some noise on a reference goal (default)
                                 &#39;random&#39;: Choose a point in goal space
                                 np.ndarray: A specific goal of shape
                                 (num_envs, len(goal_filter))
            `reward_fn`:         Optional reward function that takes an observation dict.
            `scale_observation`: Scale the observations and goals as specified in trafo
            `auto_reset`:        Automatically reset environemt when done.
        &#34;&#34;&#34;

        self.ace_id: str       = ace_id
        self.ace_backend: str  = ace_backend
        self.num_envs: int     = num_envs

        self.auto_reset: bool  = auto_reset

        self.num_steps: int    = num_steps
        self.steps: np.array   = np.zeros(num_envs)

        self.ace_envs          = ac.make_same_env_pool( self.num_envs
                                                      , self.ace_id
                                                      , self.ace_backend )

        self.constraints       = ac.parameter_dict(self.ace_envs[0])

        const_params           = { k: v[&#39;init&#39;]
                                   for k,v in self.constraints.items()
                                   if not v[&#39;sizing&#39;] }

        ac.set_parameters_pool( self.ace_envs
                              , { i: const_params
                                  for i in range(self.num_envs) }
                              , )

        perf_ids               = sorted(ac.performance_identifiers(self.ace_envs[0]))
        self.obs_filter        = ( perf_ids if obs_filter == &#39;all&#39; else
                                   [p for p in perf_ids
                                      if (p.islower() or (p == &#39;A&#39;)
                                                      or (p.startswith(&#39;vn_&#39;)))]
                                   if obs_filter == &#39;perf&#39; else
                                   obs_filter if isinstance(obs_filter, list)
                                   else ValueError(&#39;Wrong Argument type passed to obs_filter.&#39;) )
        self.obs_idx           = np.array([ i for i,p in enumerate(self.obs_filter)
                                            if p in self.obs_filter ])

        self.obs_scaler,\
        self.obs_unscaler      = performance_scaler( self.ace_id
                                                   , self.ace_backend
                                                   , self.constraints
                                                   , self.obs_filter
                                                   , )

        self.input_parameters  = ac.sizing_identifiers(self.ace_envs[0])

        self.goal_filter       = goal_filter or [ ident for ident in self.obs_filter
                                                  if ident.islower() or (ident == &#39;A&#39;) ]

        self.goal_idx          = np.array([i for i,p in enumerate(self.obs_filter)
                                             if p in self.goal_filter])

        self.goal_preds        = goal_preds or goal_predicate(self.goal_filter)

        self.goal_scaler, \
        self.goal_unscaler     = performance_scaler( self.ace_id
                                                   , self.ace_backend
                                                   , self.constraints
                                                   , self.goal_filter
                                                   , )

        self.calculate_reward  = reward_fn or partial(binary_reward, self.goal_preds)

        self.action_space      = Box( low   = -1.0
                                    , high  = 1.0
                                    , shape = (len(self.input_parameters),)
                                    , dtype = np.float32 )

        self.observation_space = Dict({ &#39;observation&#39;:   Box( -np.Inf, np.Inf
                                                            , (len(self.obs_filter),))
                                      , &#39;achieved_goal&#39;: Box( -np.Inf, np.Inf
                                                            , (len(self.goal_filter),))
                                      , &#39;desired_goal&#39;:  Box( -np.Inf, np.Inf
                                                            , (len(self.goal_filter),))
                                      , })

        self.scale_observation = scale_observation

        self.rng_seed          = seed

        reference              = ac.evaluate_circuit_pool(self.ace_envs)[0]

        if isinstance(goal_init, str) and goal_init == &#39;noisy&#39;:
            self.goal_init      = goal_init
            ref_goal_op         = reference_goal( self.ace_id, self.ace_backend
                                                , self.constraints )
            ref_goal            = { gf: ref_goal_op.get(gf, reference[gf])
                                    for gf in self.goal_filter }
            ref_goals           = { i: ref_goal for i in range(self.num_envs) }

            self.reference_goal = filter_results( self.goal_filter
                                                , ref_goals )
        elif isinstance(goal_init, str) and goal_init == &#39;random&#39;:
            self.goal_init      = goal_init
            x_min_d, x_max_d    = performance_scale( self.ace_id
                                                   , self.ace_backend
                                                   , self.constraints
                                                   , )
            self.reference_goal = np.array([ [x_min_d[gp] for gp in self.goal_filter]
                                           , [x_max_d[gp] for gp in self.goal_filter]
                                           ])
        elif isinstance(goal_init, np.ndarray):
            self.goal_init      = &#39;fix&#39;
            goal_shape          = (num_envs, len(self.goal_filter))
            self.reference_goal = ( goal_init
                                    if goal_init.shape == goal_shape else
                                    np.repeat(goal_init[None], num_envs, axis = 0) )
        else:
            NotImplementedError(f&#39;Goal initializer {goal_init} not available.&#39;)

        self.new_goal          = goal_generator( self.goal_init
                                               , self.reference_goal
                                               , self.num_envs
                                               , )
        self.goal              = self.new_goal()

        self.act_unscaler      = geometric_unscaler(self.constraints)

        self.sizing            = {}

        VecEnv.__init__( self, self.num_envs
                       , self.observation_space
                       , self.action_space )

    def close(self, env_ids: list[int] = None) -&gt; None:
        &#34;&#34;&#34;
        Close all (parallel) ACE environment(s).
        Arguments:
            `env_ids`: List of environment IDs that will be closed.
                       Default = None closes all.
        &#34;&#34;&#34;
        for env_id in (env_ids or self.ace_envs.keys()):
            self.ace_envs[env_id].clear()

    def observation_dict( self, observation: dict[int, dict[str, float]]
                        ) -&gt; dict[str, np.ndarray]:
        &#34;&#34;&#34;
        Takes an observation from a pooled ACE Environment and returns a
        GoalEnv compliant OrderedDict.
        &#34;&#34;&#34;
        state       = filter_results(self.obs_filter, observation)
        achieved    = filter_results(self.goal_filter, observation)

        obs         = np.nan_to_num( self.obs_scaler(state)
                                     if self.scale_observation else state )
        a_goal      = np.nan_to_num( self.goal_scaler(achieved)
                                     if self.scale_observation else achieved )
        d_goal      = np.nan_to_num( self.goal_scaler(self.goal)
                                     if self.scale_observation else self.goal )

        return OrderedDict({ &#39;observation&#39;:   obs
                           , &#39;achieved_goal&#39;: a_goal
                           , &#39;desired_goal&#39;:  d_goal })

    def reset(self, env_mask: list[bool] = [], env_ids: list[int] = []):
        &#34;&#34;&#34;
        Reset all (parallel) environment(s).
        Arguments:
            `env_mask`: Boolean mask of environemts that will be reset. Passing
                        the `done` vector works. This argument is prioritized
                        over `env_ids`.
            `env_ids`: List of integer IDs of environments that will be reset.
                       This argument is discarded in favour of `env_mask`.
        &#34;&#34;&#34;

        previous              = ac.current_performance_pool(self.ace_envs)
        prev_obs              = self.observation_dict(previous)
        state                 = prev_obs[&#39;observation&#39;]
        achieved              = prev_obs[&#39;achieved_goal&#39;]

        reset_ids             = [ i for i,m in enumerate(env_mask) if m
                                ] or env_ids or range(self.num_envs)

        pool                  = { i: self.ace_envs[i] for i in reset_ids }
        random_sizing         = ac.random_sizing_pool(pool)
        results               = ac.evaluate_circuit_pool( pool
                                                        , pool_params = random_sizing
                                                        , )

        observation           = self.observation_dict(results)

        state[reset_ids]      = observation[&#39;observation&#39;]
        achieved[reset_ids]   = observation[&#39;achieved_goal&#39;]

        self.goal[reset_ids]  = self.new_goal()[reset_ids]

        goal                  = ( self.goal_scaler(self.goal)
                                  if self.scale_observation else
                                  self.goal )

        self.steps[reset_ids] = 0

        return OrderedDict({ &#39;observation&#39;:   state
                           , &#39;achieved_goal&#39;: achieved
                           , &#39;desired_goal&#39;:  goal })

    def step(self, actions: np.ndarray) -&gt; VecEnvStepReturn:
        &#34;&#34;&#34;
        Take a step in the Environment. Calls `step_async` and `step_wait`
        under the hood.
        Arguments:
            `actions`: Take Action with shape [num_envs, action_space].
        &#34;&#34;&#34;
        self.step_async(actions)
        return self.step_wait()

    def step_async(self, actions: np.ndarray) -&gt; None:
        &#34;&#34;&#34;
        Initiate a step in the Environment.
        Arguments:
            `actions`: Take Action with shape [num_envs, action_space].
        &#34;&#34;&#34;

        unscaled    = self.act_unscaler(np.clip( actions
                                               , self.action_space.low
                                               , self.action_space.high ))
        params      = sorted(ac.sizing_identifiers(self.ace_envs[0]))
        self.sizing = { env_id: dict(zip(params, action.tolist()))
                        for env_id,action in enumerate(list(unscaled))}

    def step_wait(self) -&gt; VecEnvStepReturn:
        &#34;&#34;&#34;
        Complete a step in the Environment.
        &#34;&#34;&#34;
        pool        = { i: self.ace_envs[i] for i in range(self.num_envs) }
        results     = ac.evaluate_circuit_pool(pool, pool_params = self.sizing)

        observation = self.observation_dict(results)

        reward      = self.calculate_reward(observation)

        self.steps  = self.steps + 1

        done        = (reward == 0) | (self.steps &gt;= self.num_steps)

        info_dict   = { &#39;outputs&#39;: self.obs_filter
                      , &#39;goal&#39;:    self.goal_filter
                      , &#39;inputs&#39;:  self.input_parameters
                      , }

        info        = [ info_dict | {&#39;is_success&#39;: s} for s in (reward == 0).tolist() ]

        if self.auto_reset and done.any():
            for i in range(len(info)):
                info[i][&#34;terminal_obs&#34;] = observation[&#34;observation&#34;][i]
                info[i][&#34;target&#34;] = observation[&#34;desired_goal&#34;][i]
            observation = self.reset(done)

        return (observation, reward, done, info)

    def compute_reward( self, achieved_goal: object, desired_goal: object
                      , info: Mapping[str, Any] ) -&gt; np.array:
        &#34;&#34;&#34;
        Externalized reward calculation for stable baselines compatibility.
        Calls `self.calculate_reward` under the hood.
        &#34;&#34;&#34;
        observation = { &#34;achieved_goal&#34;: achieved_goal
                      , &#34;desired_goal&#34;:  desired_goal
                      , }
        return self.calculate_reward(observation = observation)

    def get_attr( self, attr_name: str, indices: VecEnvIndices = None
                ) -&gt; List[Any]:
        target_envs = self._get_target_envs(indices)
        return [getattr(env_i, attr_name) for env_i in target_envs]

    def set_attr( self, attr_name: str, value: Any
                , indices: VecEnvIndices = None) -&gt; None:
        target_envs = self._get_target_envs(indices)
        for env_i in target_envs:
            setattr(env_i, attr_name, value)

    def env_method( self, method_name: str, *method_args
                  , indices: VecEnvIndices = None, **method_kwargs
                  ) -&gt; List[Any]:
        target_envs = self._get_target_envs(indices)
        return [ getattr(env_i, method_name)(*method_args, **method_kwargs)
                 for env_i in target_envs ]

    def env_is_wrapped( self, wrapper_class: Type[gym.Wrapper]
                      , indices: VecEnvIndices = None) -&gt; List[bool]:
        return [False for _ in range(self.num_envs)]

    def _get_target_envs(self, indices: VecEnvIndices) -&gt; List[gym.Env]:
        return [self]

    def seed(self, seed: Optional[int] = None) -&gt; List[Union[None, int]]:
        self.rng_seed = seed
        return [self.rng_seed] * self.num_envs

    def render(self, mode: str = &#39;human&#39;) -&gt; Optional[np.ndarray]:
        pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>gym.core.GoalEnv</li>
<li>gym.core.Env</li>
<li>stable_baselines3.common.vec_env.base_vec_env.VecEnv</li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="circus.circus.CircusElec" href="#circus.circus.CircusElec">CircusElec</a></li>
<li><a title="circus.circus.CircusGeomVec" href="#circus.circus.CircusGeomVec">CircusGeomVec</a></li>
<li><a title="circus.gym.op.OPGeomV0" href="gym/op.html#circus.gym.op.OPGeomV0">OPGeomV0</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="circus.circus.CircusGeom.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self, env_ids:Â list[int]Â =Â None) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Close all (parallel) ACE environment(s).</p>
<h2 id="arguments">Arguments</h2>
<p><code>env_ids</code>: List of environment IDs that will be closed.
Default = None closes all.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self, env_ids: list[int] = None) -&gt; None:
    &#34;&#34;&#34;
    Close all (parallel) ACE environment(s).
    Arguments:
        `env_ids`: List of environment IDs that will be closed.
                   Default = None closes all.
    &#34;&#34;&#34;
    for env_id in (env_ids or self.ace_envs.keys()):
        self.ace_envs[env_id].clear()</code></pre>
</details>
</dd>
<dt id="circus.circus.CircusGeom.compute_reward"><code class="name flex">
<span>def <span class="ident">compute_reward</span></span>(<span>self, achieved_goal:Â object, desired_goal:Â object, info:Â Mapping[str,Â Any]) â€‘>Â <built-inÂ functionÂ array></span>
</code></dt>
<dd>
<div class="desc"><p>Externalized reward calculation for stable baselines compatibility.
Calls <code>self.calculate_reward</code> under the hood.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_reward( self, achieved_goal: object, desired_goal: object
                  , info: Mapping[str, Any] ) -&gt; np.array:
    &#34;&#34;&#34;
    Externalized reward calculation for stable baselines compatibility.
    Calls `self.calculate_reward` under the hood.
    &#34;&#34;&#34;
    observation = { &#34;achieved_goal&#34;: achieved_goal
                  , &#34;desired_goal&#34;:  desired_goal
                  , }
    return self.calculate_reward(observation = observation)</code></pre>
</details>
</dd>
<dt id="circus.circus.CircusGeom.env_is_wrapped"><code class="name flex">
<span>def <span class="ident">env_is_wrapped</span></span>(<span>self, wrapper_class:Â Type[gym.core.Wrapper], indices:Â Union[ForwardRef(None),Â int,Â Iterable[int]]Â =Â None) â€‘>Â List[bool]</span>
</code></dt>
<dd>
<div class="desc"><p>Check if environments are wrapped with a given wrapper.</p>
<p>:param method_name: The name of the environment method to invoke.
:param indices: Indices of envs whose method to call
:param method_args: Any positional arguments to provide in the call
:param method_kwargs: Any keyword arguments to provide in the call
:return: True if the env is wrapped, False otherwise, for each env queried.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def env_is_wrapped( self, wrapper_class: Type[gym.Wrapper]
                  , indices: VecEnvIndices = None) -&gt; List[bool]:
    return [False for _ in range(self.num_envs)]</code></pre>
</details>
</dd>
<dt id="circus.circus.CircusGeom.env_method"><code class="name flex">
<span>def <span class="ident">env_method</span></span>(<span>self, method_name:Â str, *method_args, indices:Â Union[ForwardRef(None),Â int,Â Iterable[int]]Â =Â None, **method_kwargs) â€‘>Â List[Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Call instance methods of vectorized environments.</p>
<p>:param method_name: The name of the environment method to invoke.
:param indices: Indices of envs whose method to call
:param method_args: Any positional arguments to provide in the call
:param method_kwargs: Any keyword arguments to provide in the call
:return: List of items returned by the environment's method call</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def env_method( self, method_name: str, *method_args
              , indices: VecEnvIndices = None, **method_kwargs
              ) -&gt; List[Any]:
    target_envs = self._get_target_envs(indices)
    return [ getattr(env_i, method_name)(*method_args, **method_kwargs)
             for env_i in target_envs ]</code></pre>
</details>
</dd>
<dt id="circus.circus.CircusGeom.get_attr"><code class="name flex">
<span>def <span class="ident">get_attr</span></span>(<span>self, attr_name:Â str, indices:Â Union[ForwardRef(None),Â int,Â Iterable[int]]Â =Â None) â€‘>Â List[Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Return attribute from vectorized environment.</p>
<p>:param attr_name: The name of the attribute whose value to return
:param indices: Indices of envs to get attribute from
:return: List of values of 'attr_name' in all environments</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attr( self, attr_name: str, indices: VecEnvIndices = None
            ) -&gt; List[Any]:
    target_envs = self._get_target_envs(indices)
    return [getattr(env_i, attr_name) for env_i in target_envs]</code></pre>
</details>
</dd>
<dt id="circus.circus.CircusGeom.observation_dict"><code class="name flex">
<span>def <span class="ident">observation_dict</span></span>(<span>self, observation:Â dict[int,Â dict[str,Â float]]) â€‘>Â dict[str,Â numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc"><p>Takes an observation from a pooled ACE Environment and returns a
GoalEnv compliant OrderedDict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def observation_dict( self, observation: dict[int, dict[str, float]]
                    ) -&gt; dict[str, np.ndarray]:
    &#34;&#34;&#34;
    Takes an observation from a pooled ACE Environment and returns a
    GoalEnv compliant OrderedDict.
    &#34;&#34;&#34;
    state       = filter_results(self.obs_filter, observation)
    achieved    = filter_results(self.goal_filter, observation)

    obs         = np.nan_to_num( self.obs_scaler(state)
                                 if self.scale_observation else state )
    a_goal      = np.nan_to_num( self.goal_scaler(achieved)
                                 if self.scale_observation else achieved )
    d_goal      = np.nan_to_num( self.goal_scaler(self.goal)
                                 if self.scale_observation else self.goal )

    return OrderedDict({ &#39;observation&#39;:   obs
                       , &#39;achieved_goal&#39;: a_goal
                       , &#39;desired_goal&#39;:  d_goal })</code></pre>
</details>
</dd>
<dt id="circus.circus.CircusGeom.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self, mode:Â strÂ =Â 'human') â€‘>Â Optional[numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc"><p>Renders the environment.</p>
<p>The set of supported modes varies per environment. (And some
environments do not support rendering at all.) By convention,
if mode is:</p>
<ul>
<li>human: render to the current display or terminal and
return nothing. Usually for human consumption.</li>
<li>rgb_array: Return an numpy.ndarray with shape (x, y, 3),
representing RGB values for an x-by-y pixel image, suitable
for turning into a video.</li>
<li>ansi: Return a string (str) or StringIO.StringIO containing a
terminal-style text representation. The text can include newlines
and ANSI escape sequences (e.g. for colors).</li>
</ul>
<h2 id="note">Note</h2>
<p>Make sure that your class's metadata 'render.modes' key includes
the list of supported modes. It's recommended to call super()
in implementations to use the functionality of this method.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mode</code></strong> :&ensp;<code>str</code></dt>
<dd>the mode to render with</dd>
</dl>
<p>Example:</p>
<p>class MyEnv(Env):
metadata = {'render.modes': ['human', 'rgb_array']}</p>
<pre><code>def render(self, mode='human'):
    if mode == 'rgb_array':
        return np.array(...) # return RGB frame suitable for video
    elif mode == 'human':
        ... # pop up a window and render
    else:
        super(MyEnv, self).render(mode=mode) # just raise an exception
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def render(self, mode: str = &#39;human&#39;) -&gt; Optional[np.ndarray]:
    pass</code></pre>
</details>
</dd>
<dt id="circus.circus.CircusGeom.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self, env_mask:Â list[bool]Â =Â [], env_ids:Â list[int]Â =Â [])</span>
</code></dt>
<dd>
<div class="desc"><p>Reset all (parallel) environment(s).</p>
<h2 id="arguments">Arguments</h2>
<p><code>env_mask</code>: Boolean mask of environemts that will be reset. Passing
the <code>done</code> vector works. This argument is prioritized
over <code>env_ids</code>.
<code>env_ids</code>: List of integer IDs of environments that will be reset.
This argument is discarded in favour of <code>env_mask</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self, env_mask: list[bool] = [], env_ids: list[int] = []):
    &#34;&#34;&#34;
    Reset all (parallel) environment(s).
    Arguments:
        `env_mask`: Boolean mask of environemts that will be reset. Passing
                    the `done` vector works. This argument is prioritized
                    over `env_ids`.
        `env_ids`: List of integer IDs of environments that will be reset.
                   This argument is discarded in favour of `env_mask`.
    &#34;&#34;&#34;

    previous              = ac.current_performance_pool(self.ace_envs)
    prev_obs              = self.observation_dict(previous)
    state                 = prev_obs[&#39;observation&#39;]
    achieved              = prev_obs[&#39;achieved_goal&#39;]

    reset_ids             = [ i for i,m in enumerate(env_mask) if m
                            ] or env_ids or range(self.num_envs)

    pool                  = { i: self.ace_envs[i] for i in reset_ids }
    random_sizing         = ac.random_sizing_pool(pool)
    results               = ac.evaluate_circuit_pool( pool
                                                    , pool_params = random_sizing
                                                    , )

    observation           = self.observation_dict(results)

    state[reset_ids]      = observation[&#39;observation&#39;]
    achieved[reset_ids]   = observation[&#39;achieved_goal&#39;]

    self.goal[reset_ids]  = self.new_goal()[reset_ids]

    goal                  = ( self.goal_scaler(self.goal)
                              if self.scale_observation else
                              self.goal )

    self.steps[reset_ids] = 0

    return OrderedDict({ &#39;observation&#39;:   state
                       , &#39;achieved_goal&#39;: achieved
                       , &#39;desired_goal&#39;:  goal })</code></pre>
</details>
</dd>
<dt id="circus.circus.CircusGeom.seed"><code class="name flex">
<span>def <span class="ident">seed</span></span>(<span>self, seed:Â Optional[int]Â =Â None) â€‘>Â List[Optional[int]]</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the seed for this env's random number generator(s).</p>
<h2 id="note">Note</h2>
<p>Some environments use multiple pseudorandom number generators.
We want to capture all such seeds used in order to ensure that
there aren't accidental correlations between multiple generators.</p>
<h2 id="returns">Returns</h2>
<p>list<bigint>: Returns the list of seeds used in this env's random
number generators. The first value in the list should be the
"main" seed, or the value which a reproducer should pass to
'seed'. Often, the main seed equals the provided 'seed', but
this won't be true if seed=None, for example.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def seed(self, seed: Optional[int] = None) -&gt; List[Union[None, int]]:
    self.rng_seed = seed
    return [self.rng_seed] * self.num_envs</code></pre>
</details>
</dd>
<dt id="circus.circus.CircusGeom.set_attr"><code class="name flex">
<span>def <span class="ident">set_attr</span></span>(<span>self, attr_name:Â str, value:Â Any, indices:Â Union[ForwardRef(None),Â int,Â Iterable[int]]Â =Â None) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Set attribute inside vectorized environments.</p>
<p>:param attr_name: The name of attribute to assign new value
:param value: Value to assign to <code>attr_name</code>
:param indices: Indices of envs to assign value
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_attr( self, attr_name: str, value: Any
            , indices: VecEnvIndices = None) -&gt; None:
    target_envs = self._get_target_envs(indices)
    for env_i in target_envs:
        setattr(env_i, attr_name, value)</code></pre>
</details>
</dd>
<dt id="circus.circus.CircusGeom.step"><code class="name flex">
<span>def <span class="ident">step</span></span>(<span>self, actions:Â numpy.ndarray) â€‘>Â Tuple[Union[numpy.ndarray,Â Dict[str,Â numpy.ndarray],Â Tuple[numpy.ndarray,Â ...]],Â numpy.ndarray,Â numpy.ndarray,Â List[Dict]]</span>
</code></dt>
<dd>
<div class="desc"><p>Take a step in the Environment. Calls <code>step_async</code> and <code>step_wait</code>
under the hood.</p>
<h2 id="arguments">Arguments</h2>
<p><code>actions</code>: Take Action with shape [num_envs, action_space].</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def step(self, actions: np.ndarray) -&gt; VecEnvStepReturn:
    &#34;&#34;&#34;
    Take a step in the Environment. Calls `step_async` and `step_wait`
    under the hood.
    Arguments:
        `actions`: Take Action with shape [num_envs, action_space].
    &#34;&#34;&#34;
    self.step_async(actions)
    return self.step_wait()</code></pre>
</details>
</dd>
<dt id="circus.circus.CircusGeom.step_async"><code class="name flex">
<span>def <span class="ident">step_async</span></span>(<span>self, actions:Â numpy.ndarray) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Initiate a step in the Environment.</p>
<h2 id="arguments">Arguments</h2>
<p><code>actions</code>: Take Action with shape [num_envs, action_space].</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def step_async(self, actions: np.ndarray) -&gt; None:
    &#34;&#34;&#34;
    Initiate a step in the Environment.
    Arguments:
        `actions`: Take Action with shape [num_envs, action_space].
    &#34;&#34;&#34;

    unscaled    = self.act_unscaler(np.clip( actions
                                           , self.action_space.low
                                           , self.action_space.high ))
    params      = sorted(ac.sizing_identifiers(self.ace_envs[0]))
    self.sizing = { env_id: dict(zip(params, action.tolist()))
                    for env_id,action in enumerate(list(unscaled))}</code></pre>
</details>
</dd>
<dt id="circus.circus.CircusGeom.step_wait"><code class="name flex">
<span>def <span class="ident">step_wait</span></span>(<span>self) â€‘>Â Tuple[Union[numpy.ndarray,Â Dict[str,Â numpy.ndarray],Â Tuple[numpy.ndarray,Â ...]],Â numpy.ndarray,Â numpy.ndarray,Â List[Dict]]</span>
</code></dt>
<dd>
<div class="desc"><p>Complete a step in the Environment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def step_wait(self) -&gt; VecEnvStepReturn:
    &#34;&#34;&#34;
    Complete a step in the Environment.
    &#34;&#34;&#34;
    pool        = { i: self.ace_envs[i] for i in range(self.num_envs) }
    results     = ac.evaluate_circuit_pool(pool, pool_params = self.sizing)

    observation = self.observation_dict(results)

    reward      = self.calculate_reward(observation)

    self.steps  = self.steps + 1

    done        = (reward == 0) | (self.steps &gt;= self.num_steps)

    info_dict   = { &#39;outputs&#39;: self.obs_filter
                  , &#39;goal&#39;:    self.goal_filter
                  , &#39;inputs&#39;:  self.input_parameters
                  , }

    info        = [ info_dict | {&#39;is_success&#39;: s} for s in (reward == 0).tolist() ]

    if self.auto_reset and done.any():
        for i in range(len(info)):
            info[i][&#34;terminal_obs&#34;] = observation[&#34;observation&#34;][i]
            info[i][&#34;target&#34;] = observation[&#34;desired_goal&#34;][i]
        observation = self.reset(done)

    return (observation, reward, done, info)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="circus.circus.CircusGeomVec"><code class="flex name class">
<span>class <span class="ident">CircusGeomVec</span></span>
<span>(</span><span>reward_fn:Â CallableÂ =Â &lt;function dummy_reward&gt;, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Geometric Sizing Non-Goal Environment </p>
<p>Construct Geometric Sizing Non-Goal Environment. Same Arguments as
<code><a title="circus.circus.CircusGeom" href="#circus.circus.CircusGeom">CircusGeom</a></code> but different default <code>reward_fn</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CircusGeomVec(CircusGeom):
    &#34;&#34;&#34; Geometric Sizing Non-Goal Environment &#34;&#34;&#34;
    def __init__(self, reward_fn: Callable = dummy_reward, **kwargs):
        &#34;&#34;&#34;
        Construct Geometric Sizing Non-Goal Environment. Same Arguments as
        `CircusGeom` but different default `reward_fn`.
        &#34;&#34;&#34;
        super().__init__(**(kwargs | {&#39;reward_fn&#39;: reward_fn}))
        self.observation_space = self.observation_space[&#39;observation&#39;]

    def reset(self, **kwargs) -&gt; np.array:
        obs = super().reset(**kwargs)
        return obs[&#39;observation&#39;]

    def step_wait(self) -&gt; VecEnvStepReturn:
        obs, reward, done, info = super().step_wait()
        observation        = obs[&#39;observation&#39;]
        return (observation, reward, done, info)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="circus.circus.CircusGeom" href="#circus.circus.CircusGeom">CircusGeom</a></li>
<li>gym.core.GoalEnv</li>
<li>gym.core.Env</li>
<li>stable_baselines3.common.vec_env.base_vec_env.VecEnv</li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="circus.gym.op.OPGeomV1" href="gym/op.html#circus.gym.op.OPGeomV1">OPGeomV1</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="circus.circus.CircusGeom" href="#circus.circus.CircusGeom">CircusGeom</a></b></code>:
<ul class="hlist">
<li><code><a title="circus.circus.CircusGeom.close" href="#circus.circus.CircusGeom.close">close</a></code></li>
<li><code><a title="circus.circus.CircusGeom.compute_reward" href="#circus.circus.CircusGeom.compute_reward">compute_reward</a></code></li>
<li><code><a title="circus.circus.CircusGeom.env_is_wrapped" href="#circus.circus.CircusGeom.env_is_wrapped">env_is_wrapped</a></code></li>
<li><code><a title="circus.circus.CircusGeom.env_method" href="#circus.circus.CircusGeom.env_method">env_method</a></code></li>
<li><code><a title="circus.circus.CircusGeom.get_attr" href="#circus.circus.CircusGeom.get_attr">get_attr</a></code></li>
<li><code><a title="circus.circus.CircusGeom.observation_dict" href="#circus.circus.CircusGeom.observation_dict">observation_dict</a></code></li>
<li><code><a title="circus.circus.CircusGeom.render" href="#circus.circus.CircusGeom.render">render</a></code></li>
<li><code><a title="circus.circus.CircusGeom.reset" href="#circus.circus.CircusGeom.reset">reset</a></code></li>
<li><code><a title="circus.circus.CircusGeom.seed" href="#circus.circus.CircusGeom.seed">seed</a></code></li>
<li><code><a title="circus.circus.CircusGeom.set_attr" href="#circus.circus.CircusGeom.set_attr">set_attr</a></code></li>
<li><code><a title="circus.circus.CircusGeom.step" href="#circus.circus.CircusGeom.step">step</a></code></li>
<li><code><a title="circus.circus.CircusGeom.step_async" href="#circus.circus.CircusGeom.step_async">step_async</a></code></li>
<li><code><a title="circus.circus.CircusGeom.step_wait" href="#circus.circus.CircusGeom.step_wait">step_wait</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="circus" href="index.html">circus</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="circus.circus.make" href="#circus.circus.make">make</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="circus.circus.CircusElec" href="#circus.circus.CircusElec">CircusElec</a></code></h4>
</li>
<li>
<h4><code><a title="circus.circus.CircusElecVec" href="#circus.circus.CircusElecVec">CircusElecVec</a></code></h4>
</li>
<li>
<h4><code><a title="circus.circus.CircusGeom" href="#circus.circus.CircusGeom">CircusGeom</a></code></h4>
<ul class="two-column">
<li><code><a title="circus.circus.CircusGeom.close" href="#circus.circus.CircusGeom.close">close</a></code></li>
<li><code><a title="circus.circus.CircusGeom.compute_reward" href="#circus.circus.CircusGeom.compute_reward">compute_reward</a></code></li>
<li><code><a title="circus.circus.CircusGeom.env_is_wrapped" href="#circus.circus.CircusGeom.env_is_wrapped">env_is_wrapped</a></code></li>
<li><code><a title="circus.circus.CircusGeom.env_method" href="#circus.circus.CircusGeom.env_method">env_method</a></code></li>
<li><code><a title="circus.circus.CircusGeom.get_attr" href="#circus.circus.CircusGeom.get_attr">get_attr</a></code></li>
<li><code><a title="circus.circus.CircusGeom.observation_dict" href="#circus.circus.CircusGeom.observation_dict">observation_dict</a></code></li>
<li><code><a title="circus.circus.CircusGeom.render" href="#circus.circus.CircusGeom.render">render</a></code></li>
<li><code><a title="circus.circus.CircusGeom.reset" href="#circus.circus.CircusGeom.reset">reset</a></code></li>
<li><code><a title="circus.circus.CircusGeom.seed" href="#circus.circus.CircusGeom.seed">seed</a></code></li>
<li><code><a title="circus.circus.CircusGeom.set_attr" href="#circus.circus.CircusGeom.set_attr">set_attr</a></code></li>
<li><code><a title="circus.circus.CircusGeom.step" href="#circus.circus.CircusGeom.step">step</a></code></li>
<li><code><a title="circus.circus.CircusGeom.step_async" href="#circus.circus.CircusGeom.step_async">step_async</a></code></li>
<li><code><a title="circus.circus.CircusGeom.step_wait" href="#circus.circus.CircusGeom.step_wait">step_wait</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="circus.circus.CircusGeomVec" href="#circus.circus.CircusGeomVec">CircusGeomVec</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>